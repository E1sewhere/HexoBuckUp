---
title: HTTP图解读书笔记
date: 2018-10-23 20:36:22
updated:
tags: [http]
description:
keywords:
comments:
image:
---
这是我学习《HTTP图解》的笔记,由于有时是脱笔记阅读,所有可能会有一些笔记不完全.
本书已经看完,由于时间不多,之后的笔记就先搁置了,目前笔记记录到P172 响应部首-Age

<!--more-->
<hr/>

# web网络基础

## HTTP访问web

web使用HTTP（超文本传输协议）

## TCP/IP

通常的网络是在TCP/IP协议族上运作的，HTTP属于它的一个子集。



### TCP/IP协议族

TCP/IP是互联网相关的各类协议族的总称：

+ IP

+ ICMP

+ PPPoE

+ DNS

+ TCP

+ UDP

+ FTP

+ 等等



### TCP/IP分层管理

分为四层：应用层，传输层，网络层，数据链路层

+ 应用层：决定向用户提供应用服务时通信的活动，FTP、DNS、HTTP都属于该层

+ 传输层：对上层应用层（服务于应用层），提供处于网络连接中的两台计算机之间的数据。

+ 网络层：处理在网络上流动的数据包，数据包是网络传输的最小数据单位。规定了通过怎样的路径到达对方的计算机，并把数据包传输给对方

+ 数据链路层：处理连接网络的硬件部分



### TCP/IP通信传输流
![](file:///G:/%E8%B5%84%E6%96%99/http/chuanshuliu.png)

利用TCP/IP协议族进行网络通信时，会通过分层顺序于对方进行通信。发送端从应用层往下走，接受段从链路层网上走。

发送端在层与层之间传输数据时，每经过一层就会打上该层所属的部首信息。反之在接收端在层与层之间传输的时候，每经过一层会把对应的部首消去。这种方法称为封装。
![http2](file:///G:/%E8%B5%84%E6%96%99/http/http2.png)

## 与HTTP关系密切的协议：IP、TCP、DNS

### IP（Internet Protocol）网际协议

负责传输，位于网络层，区别于ip地址。

IP协议作用是把各种数据包传输给对方，需要满足两个最重要的条件就是IP地址和MAC地址。

### TCP协议
负责提供可靠的字节流服务，位于传输层。
字节流服务（BSS）：为了方便传输将大块数据分割成报文段（segment）为单位的数据包管理。
TCP为了更加容易传输大数据，将数据分割，而且TCP使用一种验证方式确认数据是否送达对方。
这种方式称为`三次握手`策略.TCP协议把数据送出后不会对传送后的情况置之不理,它一定会向对方确认是否成功送达.

握手过程使用了TCP标志(flag): `SYN`和`ACK`
三次握手的流程是,发送端首先发送一个带SYN标志的数据包给接收端,接收端收到后回传一个带有SYN/ACK标志的数据包以示传达确认信息.最后发送端再回传一个带ACK标志的数据包,代表握手结束.

### DNS服务
负责域名解析服务,同HTTP一样位于应用层的协议.,提供域名到IP地址间的解析服务.
计算机既可以被赋予IP地址,也可以被赋予主机名和域名.
DNS服务处理IP地址与域名之间的转换,DNS协议通过域名查找IP地址,或者逆向从IP地址查找域名.
![dns1](dns1.png)

## 各种协议与HTTP协议的关系
通过图片理解HTTP协议的通信过程各个协议都发挥了哪些作用:
![http3](http3.png)

## URI和URL
 
### URI(统一资源标识符)
URI是由某个协议方案表示的资源的定位标识符.协议方案是指访问资源所使用的协议类型的名称.采用HTTP协议时,协议方案就是HTTP,除此之外还有FTP,file等.

`URI`用字符串标识某一互联网资源,而`URL`表示资源的地点,URL示URI的子集.

### URI格式

#### 绝对URI格式
![uri1](uri1.png)

协议方案名:也可以是`data:`或`JavaScript`这种指定数据或脚本程序的方案名.不区分大小写.

登录认证:指定用户名和密码作为从服务器获取资源时必要的登录信息,可选项 

服务器地址:使用绝对URI必须指定待访问的服务器地址,可以是DNS能够解析的名称或者IP地址.

服务器端口号:指定服务器连接的网络端口号,可选项,省略则使用默认端口号

带层次的文件路径: 指定服务器上的文件路径来指定的特定的资源

查询字符串: 针对已经指定的文件路径内的资源可以使用查询字符串传入任意参数,当然也可以不传.

片段标识符: 可以标记出已经获取资源中的子资源,可选项

# 简单的HTTP协议 
HTTP协议通信时必然一端担任客户端,一遍是服务端,两台计算机角色可以互换,但是在一条通信路线中角色是固定的,通信路线结束后才能互换.

## 通过请求和相应的交换达成通信
请求必定从客户端发出,最后服务器响应请求并返回.服务端在没有接受到请求之前一定不会发送响应.
客户端发送请求报文,服务器发送响应报文.
请求报文由请求方法(表示请求访问服务器的类型),请求URI,协议版本,可选的请求部首字段和内容实体构成的.
![请求报文](请求报文.png)

响应报文是由协议版本,状态码,解释状态码的语句,响应部首字段,实体主体构成.
![响应报文](响应报文.png)


## HTTP--无状态协议
无状态(stateless)协议.HTTP协议自身不对请求和响应之间的通信状态进行保存.也就是说在HTTP这个级别,协议对发送过的请求或响应都不做持久化处理.
这事为了更快的处理大量事物.确保协议简洁可伸缩,特意把协议设置为如此简单.
HTTP是无状态协议但是引入了Cookie技术,这样使用HTTP协议通信就可以管理状态了.

## 请求URI定位资源
当客户端请求资源而发送请求的时候需要把URI包含在请求中,指定这个URI的方式有很多.

下面这个例子指定了以` http://hackr.jp/index.htm `作为请求的例子:

*把完整的URI包含在请求中*
![uri定位资源](uri定位资源.png)

*在部首字段`Host`中写明网络域名或者IP地址*
![uri定位资源2](uri定位资源2.png)



## 告知服务器意图的HTTP方法
### GET:获取资源
用来请求访问已被URI识别的资源.指定的资源经服务器端解析后返回响应内容.也就是说如果是文本资源就保持原样返回,如果是程序则返回服务器执行后的输出结果.
![httpget](httpget.png)

### POST:传输实体主体
POST方法用于向服务器来传输实体的主体.
GET方法也可用于传输实体的主体,但一般不用GET传输.
同样的POST也可以获取响应,但POST的主要目的不是获取响应主体内容.
![httppost](httppost.png)

### PUT:传输文件
用于传输文件,像FTP协议一样要求在请求报文追中包含文件内容,然后保存到请求URI指定的位置.PUT方法自身不带验证机制,任何人都可以上传.
![httpput](httpput.png)

### HEAD:获得报文部首
同GET方法一样只是不返回报文主体部分,用于确认URI的有消息及资源更新的日期时间等.
![httphead](httphead.png)

### DELETE:删除文件
用来删除文件,是与PUT相反的方法.按照请求URI删除制定资源.
同样的DELETE方法自身不带验证机制,任何人都可以删除.
![httpdelete](httpdelete.png)

### OPTIONS:询问支持的方法
用来查询针对请求URI指定的资源支持的方法.
![httpoptions](httpoptions.png)

### TRACE: 追踪路径  

### CONNECT:要求用隧道协议连接代理
CONNECT方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行TCP通信.主要使用 SSL（Secure Sockets Layer，安全套接
层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
![httpconnect](httpconnect.png)

## 使用方法下达命令
向请求URI指定的资源发送请求报文时,采用称为方法的命令。
方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有 GET、POST 和 HEAD 等。
方法名区分大小写，注意要用大写字母。
![http方法](http方法.png)

## 持久连接节省通信量
HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。
使用浏览器浏览一个包含多张图片的 HTML页面时，在发送
请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的
其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断
开，增加通信量的开销。

### 持久连接
持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。
持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

### 管线化
持久连接使得多数请求以管线化（pipelining）方式发送成为可能.
从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。
![管线化](管线化.png)

## 使用Cookie的状态管理
Cookie技术用来解决HTTP协议无状态的弊端.
Cookie 技术通过在请求和响应报文中写入 Cookie 信
息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做` Set-Cookie` 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。
服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。
![cookie](cookie.png)

# HTTP报文内的HTTP信息

## HTTP报文
用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。
HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。
![http报文结构](http报文结构.png)

## 请求报文及响应报文结构
p49
![报文结构2](报文结构2.png)
![报文实例](报文实例.png)


请求行: 包含请求的方法,请求URI和HTTP版本
状态行: 包含表明响应结果的状态码,原因短语的HTTP版本
部首字段:包含表示请求和响应的各种条件和属性的各类部首
  通常4种部首,分别是:通用部首,请求部首,响应部首和实体部首.
  也有HTTP的REC里未定义的部首(Cookie等)

## 编码提升传输效率
HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过
程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量
的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多
的 CPU 等资源。

### 报文主体和实体主题的差异

+ 报文(message) 是HTTP通信中的基本单位,由 8 位组字节流（octetsequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。
+ 实体(entity) 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

### 压缩传输的内容的编码
HTTP 协议中有一种被称为内容编码的功能将发送内容编码压缩后由客户端接收并解码.
内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码.

### 分割发送的分块传输编码
在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，
浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成
多块，能够让浏览器逐步显示页面。
这种把实体主体分块的功能称为分块传输编码（Chunked Transfer
Coding）。

## 发送多种数据的多部分对象集合
HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。
在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加`Content-type`.

## 获取部分内容的请求范围
以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。
要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。
对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源。
![范围请求](范围请求.png)

使用部首字段`Range`来制定传续资源byte范围,如:

+ 指定5001~10000字节 `Range: bytes=5001~10000`
+ 从5001字节之后全部 `Range: bytes=5001-`
+ 从一开始到 3000 字节和 5000~7000 字节的**多重范围** `Range: bytes=-3000,5000-7000`

范围请求的响应返回:

+ 响应会返回状态码为为 206 Partial Content 的响应报文
+ 对于多重范围的范围请求,响应会在部首字段`ContentType`表明`multipart/byteranges`后返回响应报文.
+ 如果服务器端无法(不支持)响应范围请求，则会返回状态码 200 OK 和完整的实体内容

## 内容协商返回最合适的内容
内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的言、字符集、编码方式等作为判断的基准。
包含在请求报文中的某些首部字段（Accept,Accept-Charset,Accept-Encoding等）就是判断的基准.

内容协商技术有3种类型:

+ 服务器驱动协商(Server-driven Negotiation)
 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。
+ 客户端驱动协商（Agent-driven Negotiation）
 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或移动端页面.
+ 透明协商 
 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

# 返回结果的HTTP状态码

## 状态码告知从服务器端返回的请求结果
状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

状态码: 三位数字+原因短语 `200 ok`

![状态码类别](状态码类别.png)

只要遵守状态码类别的定义,几十改变RFC2616中定义的状态吗活服务器端自行创建状态码都没问题.

## 状态码-2xx 成功
2xx地相应结果表明请求被正常处理了.

### 200 OK 
表示客户端发来的请求在服务端正常处理了

### 204 No Content
表示接收的请求处理成果,但反悔的响应报文中不含实体的主题部分.
一般用于从客户端忘服务器发送信息,而客户端不需要新信息时使用.

### 206 Partial Content
该状态码表示客户端进行了范围请求.服务器成功执行了这部分GET请求.响应报文中包含了由`Content-Range`指定范围的实体内容.

## 状态码-3xx 重定向
3xx响应结果表明浏览器需要执行默写特殊的处理以正确的处理请求.

### 301 Moved Permanently
永久性重定向.
该状态码表示请求的资源已被分配了新URI,以后 应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 
像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就 会产生 301 状态码。

```
http://example.com/sample
```

### 302 Found 
临时性重定向.
代表资源已经移动,但不是永久移动,只是临时性质.以后可能还会发生改变.用户把URI保存成书签,但不会像301一样更新书签,仍旧保留返回302状态码的页面对应的URI.

### 303 See Other
表示由于请求的资源存在另外一个URI,应该使用GET方法定向获取请求的资源.
同302呦同样的功能,但是明确表示客户端应当采用GET方法获取资源,这里与302呦区别.

### 304 NotModified
表示客户端发送`附带条件的请求`(指采用GET方法的请求报文中包含If-Match,If-ModifiedSince,If-None-Match,If-Range,If-Unmodified-Since中任一部首),服务器端允许请求访问资源,但未满足条件的情况.
304返回不包含任何响应的主题部分.合重定向没有任何关系

### 307 Temporary Redirect

临时重定向.同302有相同的含义

## 4XX客户端错误
4xx的响应结果表明`客户端`是发生错误的原因所在.

### 400 Bad Request
表明请求报文中存在语法错误,服务器无法理解请求

### 401 Unauthorized
![http401.png](https://e1sewhere.github.io/images/http401.png)

该状态码表示发送的请求需要有通过HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。

返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate
首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

### 403 Forbidden
该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。

### 404 Not Found
该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

## 5XX 服务器错误
表明服务器本身发生错误
### 500 Internal Server Error
表明服务器端在执行请求的时候发生错误,可能是web应用错误,或者某些临时故障.

### 503 Service Unabailable
服务器处于超载或者停机维护,无法处理请求.如果想要告知客户端解除时间,可以写入`RetryAfter`部首字段返回给客户端.


状态码和状况的不一致
不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。
比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。

# 与HTTP协作的Web服务器
一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。

## 用单台虚拟主机实现多个域名

即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。

所以，如果一台服务器内托管了www.tricorder.jp 和 www.hackr.jp 这
两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名.
在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

## 通讯数据转发程序:代理,网关,隧道

### 代理
代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变`请求 URI`，会直接发送给前方持有资源的目标服务
器。
持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端

![proxy1.png](proxy1.png)
每次通过代理服务器转发请求或响时，会追加写入 Via 首部信息

使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。
代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一
种是是否会修改`报文`。

#### 缓存代理
代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。
当代理再次接收到对相同资源的请时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

#### 透明代理
转发请求或者响应时,部队报文做任何加工的代理类型.反之,对报文内容进行加工的代理被称为非透明代理.

### 网关
![网关1.png](网关1.png)

利用网关可以由HTTP请求转化为其他通信协议.

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。

### 隧道
隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。
隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。

## 保存资源的缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存 可减少对源服务器的访问，因此也就节省了通信流量和通信时间。
缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话 说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资 源的副本。

### 缓存的有效期限
即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源 服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从 源服务器上获取“新”资源。

### 客户端的缓存
缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件 
浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直 接从本地磁盘内读取。
另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务 器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新 资源。

# HTTP部首

## 报文部首
![报文结构.png](https://e1sewhere.github.io/images/报文结构.png)
HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客 户端和服务器分别处理请求和响应提供所需要的信息。对于客户端用户来说，这些信息中的大部分内容都无须亲自查看。

### HTTP请求报文
在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等 部分构成
![请求报文2.png](https://e1sewhere.github.io/images/请求报文2.png)

下面的示例是访问 http://hackr.jp 时，请求报文的首部信息。

```
GET / HTTP/1.1 
Host: hackr.jp 
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0 
Accept-Language: ja,en-us;q=0.7,en;q=0.3 
Accept-Encoding: gzip, deflate 
DNT: 1 
Connection: keep-alive 
If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT 
If-None-Match: "45bae1-16a-46d776ac" 
Cache-Control: max-age=0
```

### HTTP响应报文
在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、 HTTP 首部字段 3 部分构成。
![响应报文2.png](https://e1sewhere.github.io/images/响应报文2.png)

## HTTP首部字段

### 首部字段传递重要信息
HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之 间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首 部字段，它能起到传递额外重要信息的作用。
使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的 语言、认证信息等内容。

### 首部字段结构
HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分 隔。

> 首部字段名: 字段值

例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的对象类型。

> Content-Type: text/html

另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。

> Keep-Alive: timeout=15, max=100

### 4种HTTP首部字段类型
HTTP 首部字段根据实际用途被分为以下 4 种类型: 

1. 通用首部字段（General Header Fields）:请求报文和响应报文两方都会使用的首部。
1. 请求首部字段（Request Header Fields）:从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加 内容、客户端信息、响应内容相关优先级等信息。
1. 响应首部字段（Response Header Fields）:从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加 内容，也会要求客户端附加额外的内容信息。
1. 实体首部字段（Entity Header Fields）:针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

### HTTP/1.1首部字段一览
p82
*HTTP/1.1 规范定义了如下 47 种首部字段*

#### 通用首部字段

> Cache-Control |控制缓存的行为
Connection |逐跳首部、连接的管理
Date|创建报文的日期时间
Pragma |报文指令
Trailer|报文末端的首部一览
Transfer-Encoding指定报文主体的传输编码方式
Upgrade|升级为其他协议
Via|代理服务器的相关信息
Warning |错误通知

#### 请求首部字段

> Accept|用户代理可处理的媒体类型
Accept-Charset |优先的字符集
Accept-Encoding |优先的内容编码
Accept-Language |优先的语言（自然语言）
Authorization |Web认证信息
Expect |期待服务器的特定行为
From|用户的电子邮箱地址
Host|请求资源所在服务器
If-Match |比较实体标记（ETag）
If-Modified-Since 比较资源的更新时间
If-None-Match |比较实体标记（与If-Match相反）
If-Range|资源未更新时发送实体Byte的范围请求
If-Unmodified-Since |比较资源的更新时间（与If-Modified-Since相反）
Max-Forwards |最大传输逐跳数
Proxy-Authorization 代理服务器要求客户端的认证信息
Range |实体的字节范围请求
|Referer |对请求中URI的原始获取方
|TE|传输编码的优先级
User-Agent |HTTP客户端程序的信息

#### 响应首部字段

> Accept-Ranges |是否接受字节范围请求
Age|推算资源创建经过时间
ETag|资源的匹配信息
Location|令客户端重定向至指定URI
Proxy-Authenticate |代理服务器对客户端的认证信息
Retry-After|对再次发起请求的时机要求
Server|HTTP服务器的安装信息
Vary|代理服务器缓存的管理信息
wwW-Authenticate服务器对客户端的认证信息

#### 实体首部字段

> Allow|资源可支持的HTTP方法
Content-Encoding |实体主体适用的编码方式
Content-Language|实体主体的自然语言
Content-Length |实体主体的大小（单位：字节）
Content-Location 替代对应资源的URI
Content-MD5|实体主体的报文摘要
Content-Range |实体主体的位置范围
Content-Type |实体主体的媒体类型
Expires |实体主体过期的日期时间
Last-Modified 资源的最后修改日期时间

### 非 HTTP/1.1 首部字段 

在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定 义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。 这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。 

### End-to-end 首部和 Hop-by-hop 首部 
p84
HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类 型。
**端到端首部**（End-to-end Header） 
分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必 须保存在由缓存生成的响应中，另外规定它必须被转发。
**逐跳首部**（Hop-by-hop Header）
分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再 转发。HTTP/1.1 和之后版本中，如果要
使用 hop-by-hop 首部，需提 供 Connection 首部字段。

下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外， 其他所有字段都属于端到端首部。

+ Connection 
+ Keep-Alive 
+ Proxy-Authenticate 
+ Proxy-Authorization 
+ Trailer 
+ TE 
+ Transfer-Encoding 
+ Upgrade 

## HTTP/1.1通用首部字段
p85
通用首部字段是指，请求报文和响应报文双方都会使用的首部。
某个通用首部字段的指令分为请求指令和响应指令,一个指令可以单独是响应指令或请求指令例如`only-if-cached`,也可以同时是请求响应指令例如`no-store`

### Cache-Control 字段
操作缓存的工作机制,首部字段的参数是可选的,多个指令之间通过逗号分隔.
Cache-Control的指令用于请求及相应时.

```
Cache-Control: private, max-age=0, no-cache
```

**Cache-Control指令一览**
![cachecontrol.png](https://e1sewhere.github.io/images/cachecontrol.png)

![cachecontrol2.png](https://e1sewhere.github.io/images/cachecontrol2.png)

#### 表示是否能够缓存的指令
**public指令**
缓存响应指令,表名可向任意方提供响应的缓存

**private指令**
响应只以特定的用户作为对象.
缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。

**no-cache指令 **
客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。

如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。


由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数。

```
Cache-Control: no-cache=Location
```

#### 控制可执行缓存对象的指令
**no-store**
当使用 no-store 指令  时，暗示请求（和对应的响应）或响应中包含 机密信息。
因此，该指令规定缓存,不能在本地存储请求或响应的任一部分.

#### 指定缓存期限和认证的指令
**s-maxage指令**
s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 smaxage 指令只适用于供多位用户使用的公共缓存服务器(通常指代理)。也就是 说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何 作用。
另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理

**max-age**
当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓 存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器。

当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时 间。

**min-fresh指令**
请求指令,要求缓存服务器至少返回还未过指定时间的缓存资源,比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。

**max-stale**
使用 max-stale 可指示缓存资源，即使过期也照常接收。
如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收

请求:意思是,我允许缓存者，发送一个,过期不超过指定秒数的,陈旧的缓存.    
响应:同上.

**only-if-cached指令**
使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout

**must-revalidate指令**
使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。
若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。 

**proxy-revalidate指令**
proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。

**no-transform指令**
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改 变实体主体的媒体类型。
这样做可防止缓存或代理压缩图片等类似操作。

#### Cache-Control扩展
**cache-extension token**

```
Cache-Control: private, community="UCI"
```
如上例，Cache-Control 首部字段本身没有 community 这个指令。借助 extension tokens 实现了该指令的添加。如果缓存服务器不能理解 community 这个新指令，就会直接忽略。因此，extension tokens 仅对 能理解它的缓存服务器来说是有意义的。
这就是扩展.

### Connection 字段
Connection 首部字段具备如下两个作用。

#### 控制不再转发给代理的首部字段

```
Connection: 不再转发的首部字段名
```


#### 管理持久连接

```
Connection:close
```
Http/1.1默认是持久连接的`Keep-Alive`,当服务器想明确断开连接时,则指定Connection部首字段值为`close`.

### Date字段
Date字段表明创建HTTP报文的日期和时间

```
Date: Tue,03 Jul 2012 04:40:59 GMT
```

日期的字段值有多种格式,上面的是最常见的一种.

### Pragma(译:编译)字段
HTTP1.1之前历史遗留字段,仅用于HTTP/1.0的向后兼容

```
Pragma:no-cache
```
通用首部字段,但只用于客户端发的送请求中.要求所有的中间服务器不返回缓存的资源.

所有的中间服务器如果都使用1.1为基准,就可以直接采用`Cache-Control:no-cache`指定缓存处理方式了.


### Trailer(译:预告片)字段
Trailer会事先说明在报文主体后记录了哪些首部字段.这些首部字段可应用在HTTP/1.1版本分块传输编码时.

```
HTTP/1.1 200 ok
Date:Tue,03 Julia 2050 04:05:50 GMT
Content-Type: text/HTML
...
Trailer:Expires
...报文主体...
0
Expires:Tue ,28 Sep 2049 23.55.22 GMT
```

上面的例子中,指定首部字段`Trailer`的值为`Expires`,在报文主体之后(分块长度0之后)出现了首部字段`Expires`

### Transfer-Encoding(未理解)
规定了传输**报文主体**时采用的编码方式.

### Upgrade字段
首部字段Upgrade用于检测HTTP协议及其他协议是否可用更高的版本通讯,其参数值可以用来指定一个完全不同的通信协议

```
GET/index.htm HTTP/1.1
Upgrade: TLS/1.0
Connection: Upgrade
```

上例子中字段`Upgrade`指定了协议,由于`Upgrade`字段作用额对象仅在邻接客户端和服务器生效.因此使用Upgrade的请求需要使用`Connection`字段指定不再转发的首部字段`Upgrade`

### Via
首部字段`Via`是为了追踪客户端与服务器之间的请求和响应报文的传输路径.
报文经过代理或者网管时,会现在首部字段`Via`中附加该服务的信息,然后再进行转发.

### Warning首部
该首部通常会告知用户一些与缓存相关的问题警告.

```
Warning:113 gw.hackr.jp:8080 "Heuristic expiration" Tue,03...
```

如上例,Warning首部的格式如下,最后日期时间部分可以省略

```
Warning:[警告码][警告的主机:端口号]"[警告的内容]" ([日期时间])
```

HTTP/1.1中定义了7种警告,警告具有拓展性,今后会追加新的警告码

![警告码.png](https://e1sewhere.github.io/images/警告码.png)

## 请求首部字段
请求首部字段是从客户端往服务器端发送请求报文中所使用的字段,用于补充请求的附加信息,客户端信息,对响应内容相关的优先级等内容.

### Accept字段

```
Accept: text/html,application/xhtml+xml,application/xml;q=0.8
```
可通知服务器,用户代理能够处理的媒体类型及媒体类型的相对优先级.可以使用`type/subtype`这种形式一次指定多种媒体类型.这个形式前半部分是媒体的类型,后半部分是文件的具体类型
若要给媒体类型指定优先级,在需要指定的媒体后使用分号隔开添加一个`q=x`,权重`q`的取值范围是0~1(可精确到小数点后三位),默认权重为1.0

### Accept-Charset(译: 接受-字符集)字段

```
Accept-Charset:iso-8859-5,unicode-1-1;q=0.8
```
可用来通知服务器,用户代理支持的字符集(Charset)及字符集的相对优先顺序.同Accept字段一样,可以一次性指定多种字符集,使用权重q来表示相对优先级.
该首部字段用于内容协商机制的服务器驱动协商

### Accept-Encoding

```
Accept-Encoding: gzip,deflate
```

用来告知服务器,用户代理支持的内容编码及内容编码的优先级顺序.可一次性指定多种内容编码.

### Accept-Language

```
Accept-Language:zh-cn,zh;q=0.9,en-us;q=0.3
```
用来告知服务器,用户代理能够处理的自然语言集(指中文英文等),以及相对优先级.

### Authorization
用来告知服务器,用户代理的认证信息(证书值).通常想要通过服务器认证的用户代理会在接收到返回的401状态吗响应后,把首部字段`Authorization`加入请求中.

![认证](https://e1sewhere.github.io/images/%E8%AE%A4%E8%AF%81.png)

### Expect字段(未理解)
客户端使用这个字段告知服务器,期望出现某种特定的行为.如果服务器无法理解客户端的期望做出回应而发生错误时,会返回状态吗417Expectation Failed

### From字段
用来告知服务器使用用户代理的用户的电子邮件地址.使用代理时,应该尽可能包含From首部字段(但是可能会因为代理不同,将电子邮件地址记录在`Uaer-Agent`首部字段内)

### Host字段

![host.png](https://e1sewhere.github.io/images/host.png)

```
Host:www.hackr.jp
```

首部字段`Host`会告知服务器,请求的资源所处的互联网主机名和端口号.Host首部字段是唯一一个必须被包含在请求首部的首部字段
首部字段`Host`和以单台服务器分配多个域名的虚拟主机的工作机制有着很密切的关联,这是首部字段`Host
`必须存在的意义.

请求被发送至服务器时,请求中的主机名会用IP地址直接替换解决.但是如果相同的IP下部署运行着多个域名,那么服务员器就会无法理解究竟是哪个域名对应的请求.因此需要用首部字段`Host`
来明确指出请求的主机名.若服务器未设定主机名那直接发送一个空值即可.

### If-Match字段
形如`If-xxx`的请求首部字段,都称之为条件请求.服务器接受到条件请求后,只有判断指定条件为真时,才会执行请求.

![ifmatch.png](https://e1sewhere.github.io/images/ifmatch.png)


```
If-Match:"123456"
```
首部字段`If-Match`,属附带条件之一,他会告知服务器匹配资源所用的`实体标记--Etag` 值.这是服务器无法使用`Etag`值

服务器会比对If-Match字段值和资源的Etag值,只有两者一致时才会执行请求.反之,返回状态码412 Precondition Failed的响应
还可以使用星号指定If-Match的字段值,此时服务器会忽略ETag的值,只要资源存在就处理请求.

### If-Modified-Since
![ims.png](https://e1sewhere.github.io/images/images/ims.png)

此字段属于附带条件之一,它会告知服务器若`If-Modified-Since`值早于资源更新时间,则希能处理该请求.若不满足,则返回状态吗304 Not Modified的响应
`If-Modified-Since`用于确认代理或客户端拥有的本地资源的有效性.
获取资源更新日期的时间,可通过确认首部字段`Last-Modified`来确定.

### If-None-Match字段
属于附带条件之一,与`If-Match`作用相反.当实体的ETag值与字段值不一致时,它就告知服务器处理该请求.
在GET或HEAD方法中使用这个字段可以获取最新的资源

### If-Range
![ifrange.png](https://e1sewhere.github.io/images/images/ifrange.png)
附带条件之一,若是字段值和`ETag`或更新的日期时间匹配一致,那个就作为范围请求处理(激活Range字段),反之则返回全部资源(忽略Range字段)

### If-Unmodified-Since
和`If-Modified-Since`作用相反,告知服务器,指定的请求资源只有在字段值内指定的日期时间之后，未发生更改的情况下才能处理请求。如果在指定日期时间后发生了更新，则返回状态码412 Precondition Failed。

### Max-Forwards
![maxforwards.png](https://e1sewhere.github.io/images/maxforwards.png)
同股票通过TRACK方法或者OPTIONS方法,发送包含首部字段`Max-Forwards`的请求时,该字段以十进制整数形式指定一个数,这个数代表可经过的服务器的最大数目.
服务器往下一个服务器转发请求之前,Max-Forward的值减一.当Max-Forwards字段值为0时,服务器会立刻返回响应,我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握.

### Proxy-Authorization
接收到从代理服务器发来的认证质询时,客户端会发送包含首部字段`Proxy-Authorization`的请求,以告知代理服务器认证所需要的信息.
这个和客户端与服务器之间的HTTP认证相似,不同处在于发生在客户端与代理之间.

### Range
对只需获取部分资源的范围请求,包含这个字段就可以告知服务器资源指定的范围.

```
Range: bytes=501-1000
```
上例表示请求获取从第501-1000字节的资源.
接收到附带Rang首部字段请求的服务器,会在处理请求后返回状态码206 Partial Content的响应.无法处理该范围请求时,则会返回状态码200 OK的响应及全部资源

### Referer
首部字段`Referer`会告知服务器,请求的原始资源的URI
客户端一般都会发送Referer首部字段给服务器.但当直接在浏览器的地址栏输入URI,或者出于安全性考虑时,也可以不发送该首部字段.

### TE
首部字段`TE`会告知服务器,客户端能够处理响应的传输编码方式,以及相应的优先级.`Accept-Encoding`用于内容编码,`TE`用于传输编码.
`TE`除了指定传输编码外,还可以指定伴随`trailer`字段的分块传输编码方式,这时,只需要把`trailers`赋值给`TE`

```
TE:trailers
```

### User-Agent
会将创建请求的浏览器和用户代理名称等信息传达给服务器.
当网络爬虫发起请求时,可能会在字段内添加作者的电子邮件.此外如果请求经过代理,那么中间也可能被添加上代理服务器的名称.

## 响应首部字段
响应首部字段是由服务器端向客户端返回响应报文中所使用的字段,用于补充响应的附加信息,服务器信息,以及对客户端的附加要求等信息.

### Accept-Ranges
用来告知客户端,服务器是否能处理范围请求

```
Accept-Ranges:bytes
```
可指定两张字段值,可处理范围请求时指定为`bytes`,繁殖指定为`none`

### Age
能告知客户端,源服务器在多久前创建了响应.字段值的单位是秒.
创建该响应的


