---
title: 计算机网络基础笔记
date: 2018-12-05 08:45:25
updated:
tags: [网络]
description:
keywords:
comments:
image:
---

这是在360培训计算机网络时做的笔记,主要为了考试服务

<!--more-->
# 初识网络
集线器:工作在OSI7层模型最底层  转发有延迟 **重要**

二层交:换机工作在OSI7层模型的第二层 转发快速 **重要**

网络组成
硬件:计算机,网络设备,线缆
软件:应用程序

按区域范围
广域网(wan):大范围内,如国家之间,主要用于互联局域网
局域网(lan):通常指几公里以内的，可以通过某种介质互联的计算机、打印机或其它设备的集合。
城域网(man):是介于LAN和WAN之间能传输语音与数据的公用网络。MAN是改进LAN（局域网）中的传输介质，扩大局域网的范围，达到包含一个大学校园、城市或都会区。它是较大型的局域网，需要的成本较高，但可以提供更快的传输速率
个人区域网(pan):指个人范围（随身携带或数米之内）的计算设备（如计算机、电话、PDA、数字相机等）组成的通信网络。个人网即可用于这些设备之间互相交换数据，也可以用于连接到高层网络或互联网

按网络类型
公用网:
专用网:


屏蔽双绞线 :昂贵抗干扰强
非屏蔽双绞线:
t568-a:白绿,绿,白橙,蓝,白蓝,橙,白棕,棕
!t568-b:白橙,橙,白绿,蓝,白蓝,绿,白棕,棕
光纤:
多模光纤:纤芯更细,损耗大,传输较单模近,
单模光纤:纤芯更粗,损耗小,传输更远,速率更高

设备的连接:
同交异直(同设备交叉线连接,不同设备直接连接),路由器与pc除外.

# 网络类型
## 拓扑类型

+ 总线形
成本低,易维护,但存在单点故障
+ 树形
特殊的星形
+ 星形
系统可靠性高,但存在单点故障
+ 环形
通过令牌控制传输
+ 部分网状
实际采用部分网状,代替全网状
+ 网状形
任意设备两两连接直接通信,费用极其昂贵

## 网络传输模式

+ 单工: 只有一方向的通信没有反方向通信,如电视
+ 半双工:通信的双方都可以发送信息,但不能同时发送
+ 全双工:可同时发送接收信息

## 网络通信类型
ipv4通信类型有单播,组播,广播

+ 单播:主机之间一对一的通讯模式,如果10个客户机需要相同数据,则需要传输10次
+ 广播:主机之间1对所有的通讯模式
+ 组播:主机之间1对1组的通讯模式,加入了一个组的主机可以接受到此组内的所有数据

## OSI分层模型
ISO:国际标准化组织
OSI:开放系统互联模型
:ISO创建OSI参考模型,希望不同的供应商网络能够相互协同工作,但迄今为止,仍然是一个伟大的目标.

### OSI优点

+ 开放的标准化接口
+ 多厂商兼容性
+ 易于理解,学习和更新协议标准
+ 实现模块化工程,降低了开发实现的复杂度
+ 便于排除故障

### 结构
1. 应用层 网路进程访问应用层 报文 为应用程序进程提供网络服务,提供身份验证
2. 表示层 数据表示 报文 确保接收系统可以读出数据,格式化数据,构建数据,协商用于应用层的数据传输语法,提供加密
 1. 确保某一系统的应用层所发送的信息可被另一系统的应用层读取
3. 会话层 主机间通信 报文 
 1. 可建立管理和终止在应用程序之间的会话
 2. 有差错会恢复能力
4. 传输层 端到端连接 网段 确保数据传输可靠,建立维护终止虚拟电路,通过错误检测和恢复,信息流控制来保障可靠性
 1. 可在发送主机系统上对数据进行分段,在接受主机系统上将数据段重组为数据流,同时又流量控制能力.
5. 网络层 数据传输 路由数据包,选择传递数据的最佳路径,支持逻辑寻址和路径选择
 1. 网络层可在位于不同地理位置的网络中的两个主机系统之间提供链接和路径选择
 2. 主要功能:编址;路由选择;拥塞控制;异种网络互联
6. 数据链路层 帧 访问介质,定义如何格式化数据以便进行传输以如何控制对网络的访问,支持错误检测
 1. 主要功能:帧同步,数据链路的建立,维持和释放;传输资源控制;流量控制;差错控制;寻址(物理mac地址);标识上层数据
7. 物理层 比特位  二进制传输,定义了电气规范,机械规范,过程规范,功能规范,用于激活,维护和终止端系统间的物理链路

### 数据封装
通过网络发送的信息称为数据或数据包
如果一台计算机要向另一台计算机发送数据,则必须首先执行数据封装的过程将数据打包,远程设备接收时,必须解封

### 对等通信
每一层只能与对应的对等层通信

# TCP/IP 协议

## 模型

![ositcpip.jpg](https://e1sewhere.github.io/images/ositcpip.jpg)

+ 应用层:
+ 传输层
+ Inernet层(网络层)
+ 网络访问层

# 网络接口层
## MAC地址

![mac地址.png](https://e1sewhere.github.io/images/mac地址.png)
数据链路层,唯一标识网卡,一台设备可以有多个网卡,多个mac地址

## 以太网帧结构
![帧结构.png](https://e1sewhere.github.io/images/帧结构.png)

## CSMA/CD
![csmacd.png](https://e1sewhere.github.io/images/csmacd.png)

带冲突控检测的载波监听多路访问技术
先听后说,边听边说,一旦冲突立即停说;等待时机然后再说

# 网络层

## Internet协议特征
![协议](https://e1sewhere.github.io/images/internet协议.png)

## IP地址作用

+ 它们可唯一标识IP网络中的每台设备
+ 每台主机（计算机、网络设备、外围设备）必须具有唯一的地址
+ IP网络地址由两部分组成：网络ID+主机ID
+ 主机ID：
 + 标识单个主机
 + 由组织分配给各设备
## IP地址的格式
![ip地址格式](https://e1sewhere.github.io/images/ipdz.png)

## IP地址分类
![ip分类.png](https://e1sewhere.github.io/images/ip分类.png)

![ip分类2.png](https://e1sewhere.github.io/images/ip分类2.png)

**特殊的网址**

+ 每一个字节都为0的地址（“0.0.0.0”）对应于当前主机；
+ IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的广播地址；
+ IP地址中凡是以“11110”开头的E类IP地址都保留用于将来和实验使用。
+ IP地址中不能以十进制“127”作为开头，该类地址中数字127．0．0．1到127．255．255．255用于回路测试，如：127.0.0.1可以代表本机IP地址，用`http://127.0.0.1`就可以测试本机中配置的Web服务器。
+ 网络ID的第一个8位组也不能全置为“0”，全“0”表示本地网络。

## 公有IP地址
A: 0.0.0.1-- 9.255.255.255 & 11.0.0.0--126.255.255.255
B:128.0.0.0--172.15.255.255 & 172.32.0.0--191.255.255.255
C: 192.0.0.0-- 192.167.255.255 &192.169.0.0--223.169.255.255
Internet主机需要唯一的公有IP地址

## 私有IP地址
![似有地址.png](https://e1sewhere.github.io/images/似有地址.png)

## IP数据报
分为首部和数据部分,首部发送在前
下面主要记录首部的信息
首部分为固定部分和可变部分
### 首部-可变部分
可变部分占32bit,4个字节,有可选字段,可选字段的长度可变,剩余的部分为空或者为填充.
当固定部首+可选字段+数据部分合起来都达不到传输要求的最低数据量时就需要首部的可变部分来填充无意义数据,以满足传输要求

### 首部-固定部分

#### 版本
![sbbb.png](https://e1sewhere.github.io/images/sbbb.png)

#### 首部长度
![sbbusd.png](https://e1sewhere.github.io/images/sbbusd.png)

#### 服务类型
![sbfwlx.png](https://e1sewhere.github.io/images/sbfwlx.png)

#### 总长度
![snzcd.png](https://e1sewhere.github.io/images/snzcd.png)

#### 标识
![sbbiaozhi.png](https://e1sewhere.github.io/images/sbbiaozhi.png)
一个报文被拆分后,每个分片的首部标识和拆分前相同

#### 标志(flag)
![sbbz.png](https://e1sewhere.github.io/images/sbbz.png)

#### 片偏移
![sbppy.png](https://e1sewhere.github.io/images/sbppy.png)

例题:一个数据报的总长度为3820字节，其数据部分为3800字节长（使用固定首部），需要分片为长度不超过1420字节的数据报片。
![sbpyl.png](https://e1sewhere.github.io/images/sbpyl.png)

#### 生存时间
生存时间（8bit）记为TTL（Time To Live），这是为了限制数据报在网络中的生存时间，其单位最初是秒，但为了方便，现在都用“跳数”作为TTL的单位。
数据报每经过一个路由器，其TTL值就减1。

#### 协议
协议（8bit）字段指出此数据报携带的数据使用何种协议
以便目的主机的IP层将数据部分上交给哪个处理过程
![sbxy.png](https://e1sewhere.github.io/images/sbxy.png)
#### 首部检验和
首部检验和（16bit）字段只检验数据报的首部不包括数据部分。
这里不采用CRC检验码而采用简单的计算方法。

##### 源地址/目的地址
![sbmd.png](https://e1sewhere.github.io/images/sbmd.png)
### 子网划分
优点
+ 小型网络易于管理
+ 总流量减少
+ 易于应用网络安全策略
 

#### 子网掩码的作用

+ 告知路由器路由时要查找的位数
+ 定义有效的位数
+ 用作测量工具,不隐藏任何信息
+ 将某个ip地址划分为网络地址和主机地址两个部分
网络地址:网络号不变,主机号全为0.

#### 默认子网掩码
![默认子网掩码.png](https://e1sewhere.github.io/images/默认子网掩码.png)
#### 子网掩码计算
从主机地址借位来划分子网

划分:
+ 确定是adc哪一类地址
+ 确定子网划分的要求 `/x?` `几个子网?` `子网内主机数量?`,更具要求写出初步的子网掩码二进制,确定1的个数
+ 借位的和 借位之前的不变,后面的位全为0, 这个ip就是当前子网在内网中的网络地址,后面的就是当前子网的主机地址
+ 子网掩码就是到ip地址的借位都是1,后面的全为0
+ 验证两个子网ip是不是同一个:如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中,由于子网ip的前面都是相同的,所以只需要`与`借位的就可以判断(借位相与)

ip+子网掩码算 网络地址
直接相与


汇聚:
需要汇聚的ip 2进制化;
前面相同的位作为网络地址,后面的全为0.
得出的地址就是汇聚后的地址,且有类长度(/x)就是前面相同的位数

#### 子网划分步骤

+ 子网地址扩展了网络部分，通过从原主机部分借位并将其指定为子网字段来创建子网地址
+ 子网和主机的最佳数量是由网络类型和所需的主机地址数量所决定的
+ 可用子网的数量取决于借用的位数可用子网的数量=2^s，其中s是借用的位数
+ 每个子网中的可用主机的数量取决于未借用的主机ID的位数每个子网中的可用主机的数量=2^h-2，其中h是未借用的主机位数保留一个地址作为网络地址保留一个地址作为广播地址

## ARP(地址解析协议)
+ ARP：地址解析协议（Address Resolution Protocol，）是在仅知道主机的IP地址时确定其物理地址的一种协议
+ 代理ARP代理:ARP是ARP协议的一个变种。对于没有配置缺省网关的计算机要和其他网络中的计算机实现通信，网关收到源计算机的ARP请求会使用自己的MAC地址与目标计算机的IP地址对源计算机进行应答
+ 无状态协议,OSI模型中属于数据链路层,TCP/IP模型中属于网络层

## ARP工作过程
![arp1.png](https://e1sewhere.github.io/images/arp1.png)

发送mac地址全为0的arp请求**广播**,接收方回应带mac地址的**单播**arp回应.

### 代理ARP工作过程
Hosta发送广播arp,路由器收到ARP发送的请求,运行代理arp,发送一个广播arp请求,请求内容和hosta相同,但是发起请求的是路由器.回应方回应请求mac地址是路由器的,ip是hosta的,然后路由器转发.
![dlarp.png](https://e1sewhere.github.io/images/dlarp.png)

### 无故ARP/反向ARP
无故ARP 主机使用自己的IP地址作为目标地址发送ARP请求:可以检查IP冲突
反向ARP  功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址:

## ICMP协议
IP协议并不是一个可靠的协议，它不保证数据被送达，那么，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP（网络控制报文）协议。

### 工作过程
ICMP的消息可以分为错误消息、请求消息和响应消息。一台主机向一个节点发送一个ICMP请求报文，如果途中没有异常（例如被路由器丢弃、目标不回应ICMP或传输失败），则目标返ICMP响应报文，说明这台主机存在。当传送IP数据包发生错误，比如主机不可达、路由不可达等等，ICMP协议将会把错误信息封包，即ICMP差错报文，然后传送回给主机，给主机一个处理错误的机会。
![icmp.png](https://e1sewhere.github.io/images/icmp.png)

### ICMP消息格式
![icmp2.png](https://e1sewhere.github.io/images/icmp2.png)

### Ping的实现原理
向网络上的另一个主机系统发送ICMP报文，如果指定系统得到了报文，它将把报文一模一样地传回给发送者，这有点象潜水艇声纳系统中使用的发声装置
### Tracert实现原理
![trecer.png](https://e1sewhere.github.io/images/trecer.png)

## IPv6 地址
16个二进制八位数

IPv6地址的长度为128位，由48位的全局前缀、16位的子网ID和64位的接口标识符组成
格式：
xx.xx.xxxx，其中x是16位的十六进制字段十六进制的A、B、C、D、E和F区分大小写
字段中的前导零是可选的连续的零字段可表示为：:每个地址只能用一次

示例：
2031：0000：130F：0000：0000：09C0：876A：130B
可表示为2031：0：130f：9c0：876a：130b
不能表示为2031：130f：9c0：876a：130b
FF01：0：0：0：0：0：0：1→FF01:：1
0：0：0：0：0：0：0：1→：:1
0：0：0：0：0：0：0→：:


**以下来自维基**
IPv6具有比IPv4大得多的编码地址空间。这是因为IPv6采用128位的地址，而IPv4使用的是32位。因此新增的地址空间支持2^128（约3.4×1038）个地址，具体数量为340,282,366,920,938,463,463,374,607,431,768,211,456 个，也可以说成16^32个，因为32位地址每位可以取16个不同的值。



### IPv6地址分类
+ 单播：
-地址用于单个接口
-IPv6有几种类型（例如，全局地址、保留地址、本地链路地址和本地站点地址）
+ 组播：-一对多
-提高网络的使用效率-使用更大的地址范围
+ 任播：
-一对最近（从单播地址空间分配）
-多个设备共享相同的地址
-所有任播节点应提供统一服务
-源设备将数据包发送到任播地址
-路由器确定最近的设备以达到目的地
-适合负载均衡和内容传输服务


# 传输层
![csc.png](https://e1sewhere.github.io/images/csc.png)

## 传输层协议
![cscxy.png](https://e1sewhere.github.io/images/cscxy.png)

## TCP
### TCP特点

+ TCP/IP协议栈的传输层
+ 为应用程序访问的网络层
+ 面向连接的协议,可靠
+ 全双工模式运行
+ 错误检查
+ 数据包序列化
+ 接收确认
+ 数据恢复功能
+ 流量控制

### TCP报头
![tcpbt.png](https://e1sewhere.github.io/images/tcpbt.png)
标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接

### TCP的连接与拆除
![scws.png](https://e1sewhere.github.io/images/scws.png)

![cc.png](https://e1sewhere.github.io/images/cc.png)
第二次握手后客户端`->`服务端的连接就释放了,服务端传输完剩余数据,向客户端发起释放请求,就是第三次握手,客户端收到后向服务端发送确认响应,第四次握手.然后服务端关闭,等待两msl,客户端也关闭.
### TCP可靠传输机制
![csqr.png](https://e1sewhere.github.io/images/csqr.png)
![图像446.png](https://e1sewhere.github.io/images/图像446.png)

![图像448.png](https://e1sewhere.github.io/images/图像448.png)
![图像449.png](https://e1sewhere.github.io/images/图像449.png)

![hcyc.png](https://e1sewhere.github.io/images/hcyc.png)

### 为什么用TCP可以在IP上实现可靠的连接

我们可以把淘宝买卖双方的关系，比作可靠的传输层TCP，因为他们之间的交易是需要确认的是可靠的。如果买家没有收到货物，肯定不能给卖家确认。但是快递公司可比作不可靠的网络层协议（IP）。卖家把一部销售给买家的手机封在一个包裹内（IP封包的过程），并且把这个包裹交给快递。对于快递的收件员，其实他并不清楚这个包裹内的东西是什么，他只用负责把这个包裹按照上面写的地址送到买家的手中（IP路由的过程）。由于网络层协议（IP）和快递一样不总是都靠谱，所以丢包是难免的。一旦出现丢包，长期没有收到快递的愤怒的买家就会找到卖家，倒霉的卖家只能把那部手机重新再发一次（一般快递都会推脱责任不予赔偿），这个过程就叫做TCP的超时重传。流着泪的卖家把新的包裹再次交给收件员，对于卖家而言这确实是再次。但是对于收件员而言，这只是一个普通的包裹，绝对不可能知道这是上次丢失包裹的一次重传。（这也是网络分层的目的，向下层隐藏上层的工作细节）。非常幸运的是，这次快递公司“不辱使命”成功完成了任务，把包裹交给了淘宝买家，买家对手机进行检查并且给卖家进行确认（TCP对数据的确认），本次会话结束。
## UDP
### UDP特点
·运行于OSI模型和TCP/IP模型的传输层
·为应用程序提供网络层接入而无需为可靠性机制付出多余开销
·属无连接协议
·提供有限的错误检查
·提供尽力传输
·不具备数据恢复功能
### UDP报头
![udp.png](https://e1sewhere.github.io/images/udp.png)

# 应用层

## 应用层概述
![yycgs.png](https://e1sewhere.github.io/images/yycgs.png)

网路层映射到传输层:
![wlcys.png](https://e1sewhere.github.io/images/wlcys.png)

传输层映射到应用层:
![cscys.png](https://e1sewhere.github.io/images/cscys.png)

应用协议层:

+ 使用UDP的应用层协议：**DNS**，TFTP，RIP，BOOTP，DHCP，SNMP，IGMP
+ 使用TCP的应用层协议：SMTP，TELNET，HTTP，FTP，**DNS**


## DHCP协议
### DHCP简介

+ ost Configuration Protocol（动态主机配置协议）的缩写；
+ DHCP是从BOOTP（Bootstrap Protocol，自举协议）发展而来；
+ DHCP采用客户端/服务器模式，服务器负责集中管理，客户端向服务器提出配置申请，服务器根据策略返回相应配置信息；
+ DHCP报文采用UDP封装。服务器端的**端口**号是67，客户端的端口号是68。

### DHCP特点
+ 即插即用性:客户端无须配置即能获得IP地址及相关参数。简化客户端网络配置，降低维护成本。
+ 统一管理:所有IP地址及相关参数信息由DHCP服务器统一管理，统一分配。
+ 使用效率高:通过IP地址租期管理，提高IP地址的使用效率。
+ 可跨网段实现:通过使用DHCP中继，可使处于不同子网中的客户端和DHCP服务器之间实现协议报文交互。

### DHCP系统组成

+ DHCP服务器
能提供DHCP功能的服务器或具有DHCP功能的网络设备
+ DHCP中继
一般为路由器或三层交换机等网络设备
+ DHCP客户端
需要动态获得IP地址的主机

### DHCP地址分配方式
+ 手工分配
根据需求，网络管理员为某些少数特定的主机（如DNS服务器、打印机）绑定固定的IP地址，其地址不会过期。
+ 自动分配
DHCP服务器为DHCP客户端动态分配租期为无限长的IP地址
+ 动态分配
主机申请IP地址最常用的方法。DHCP服务器为客户端指定一个IP地址，同时为此地址规定了一个租用期限，如果租用时间到期，客户端必须重新申请IP地址。


### DHCP报文
|协议报文|     作用    |     报文类型
| :------------- | :------------------------------------------------- | :------------ | 
| DHCP Discover | 客户端发现服务器 | 广播 |
| DHCP Offer | 服务器对DHCP Discover报文的回应 | 单播 |
| DHCP Request | 服务器选择及租期更新 | 单播 |
| DHCP Release | 请求释放已经获得的IP地址资源或取消租期 | 单播 |
| DHCP Ack/Nak | 服务器对收到的请求报文的最终的确认 | 单播 |
| DHCP Decline | 拒绝所获得的IP地址 | 广播 |
| DHCP Inform | 向DHCP服务器索要其他的配置参数 | 单播 |

### IP获取过程
#### IP地址动态获取过程
![idhq.png](https://e1sewhere.github.io/images/idhq.png)

#### IP地址拒绝和释放
![ipsf.png](https://e1sewhere.github.io/images/ipsf.png)

#### DHCP租约更新
![zygx.png](https://e1sewhere.github.io/images/zygx.png)

#### DHCP 工作原理
![dhcpyl.png](https://e1sewhere.github.io/images/dhcpyl.png)

#### DHCP中继工作原理
![dhcpzj.png](https://e1sewhere.github.io/images/dhcpzj.png)

## DNS协议
### DNS简介
DNS系统的作用：

+ 提供了主机名字和IP地址的相互转换DNS系统的模式：
+ 采用客户端/服务器模式DNS系统的结构：
+ 是一个具有树状层次结构，联机分布式数据库系统端口号：53 **重点**

域名:

+ 域是因特网中一种管理范围的划分顶级域、二级域、三级域等等
+ DNS域名结构是包括多级域名的分层结构顶级域名、二级域名、三级域名等等
+ 不同等级的域名之间使用点号分隔，级别最低的域名写在最左边，而级别最高的域名则写在最右边
+ 每一级的域名都由字母和数字组成，不区分大小写
+ 域名的根域用“.”表示，以点号结尾的域名称为完全合格域名FQDN（Full Qualified Domain Name）

DNS服务的作用:
将域名解析为IP地址

### DNS解析原理

+ DNS系统采用客户机/服务器架构，使用的传输层协议为TCP或UDP，服务器端口号53
+ 域名解析工作是通过调用服务器上的解析器软件完成的
+ DNS域名解析按照域名空间的分层树状结构自顶至下进行

### DNS服务器类型

+ 本地域名服务器
+ 授权域名服务器 
+ 根域名服务器
+ 主域名服务器
+ 辅助域名服务器

### DNS查询
#### 递归查询
+ 如果DNS服务器支持递归查询，那么当它接收到递归查询请求后，它将负责把最终的查询结果返回请求发送方。即使执行递归查询的DNS服务器无法从本地数据库返回查询结果，它也必须查询其他的DNS服务器，直到得到确认的查询结果
+ 一般客户机与本地域名服务器之间的查询交互采用的就是递归查询方式

#### 迭代查询
+ DNS服务器接收到迭代查询请求后，如果无法从本地数据库返回查询结果，它会返回一个可能知道查询结果的DNS服务器地址给请求者，由请求者自行查询该DNS服务器，以此类推，请求者最终将得到查询结果
+ 一般本地域名服务器发送至根域名服务器的查询采用的就是迭代查询

#### 反向查询
+ DNS反向查询允许DNS客户端根据已知的IP地址查找主机所对应的域
名
+ 因特网域名树中设立了一个特殊的in-addr.arpa反向查询域用于反向查询
![fxcx.png](https://e1sewhere.github.io/images/fxcx.png)


### DNSS域名解析完整过程
![ymcx.png](https://e1sewhere.github.io/images/ymcx.png)


# 主机间通信过程

## 各层设备

+ 第一层设备
![dyc.png](https://e1sewhere.github.io/images/dyc.png)
+ 第二层设备
![ercsb.png](https://e1sewhere.github.io/images/ercsb.png)
第二层编址:第二层地址为mac地址
+ 第三层设备
 + 网络层在两个主机系统之间提供连接和路径选择
 + 对于主机，这是数据链路层和NOS的上层之间的路径
 + 对于路由器，它是穿越网络的实际路径
 + 每个NOS都具有各自的第3层地址格式
 + OSI使用NSAP
 + TCP/IP使用IP地址
## 二层主机通信过程
![ec1.png](https://e1sewhere.github.io/images/ec1.png)

![ec2.png](https://e1sewhere.github.io/images/ec2.png)
![ec3.png](https://e1sewhere.github.io/images/ec3.png)
![ec4.png](https://e1sewhere.github.io/images/ec4.png)
![ec5.png](https://e1sewhere.github.io/images/ec5.png)
![ec6.png](https://e1sewhere.github.io/images/ec6.png)
![ec7.png](https://e1sewhere.github.io/images/ec7.png)
![ec8.png](https://e1sewhere.github.io/images/ec8.png)
![ec9.png](https://e1sewhere.github.io/images/ec9.png)
![ec10.png](https://e1sewhere.github.io/images/ec10.png)
## 三层主机通信过程
![sc1.png](https://e1sewhere.github.io/images/sc1.png)
![sc2.png](https://e1sewhere.github.io/images/sc2.png)
![sc3.png](https://e1sewhere.github.io/images/sc3.png)
![sc4.png](https://e1sewhere.github.io/images/sc4.png)
![sc5.png](https://e1sewhere.github.io/images/sc5.png)
![sc6.png](https://e1sewhere.github.io/images/sc6.png)
![sc7.png](https://e1sewhere.github.io/images/sc7.png)
![sc8.png](https://e1sewhere.github.io/images/sc8.png)
![sc9.png](https://e1sewhere.github.io/images/sc9.png)
![sc10.png](https://e1sewhere.github.io/images/sc10.png)
![sc11.png](https://e1sewhere.github.io/images/sc11.png)
![sc12.png](https://e1sewhere.github.io/images/sc12.png)
![sc13.png](https://e1sewhere.github.io/images/sc13.png)
![sc14.png](https://e1sewhere.github.io/images/sc14.png)
![sc15.png](https://e1sewhere.github.io/images/sc15.png)
![sc16.png](https://e1sewhere.github.io/images/sc16.png)
![sc17.png](https://e1sewhere.github.io/images/sc17.png)

# 路由基础
## 路由原理
+ 路由是指导IP报文发送的路径信息
+ 路由器的特点是逐跳转发

### 路由表构成
![lybgc.png](https://e1sewhere.github.io/images/lybgc.png)

### 路由项的分类
+ 主机路由：掩码长度是32位的路由，表明此路由匹配单一IP地址。
+ 子网路由：掩码长度小于32但大于0，表明此路由匹配一个子网。
+ 默认路由：掩码长度为0，表明此路由匹配全部IP地址

### 路由表查找规则
#### 最长匹配转发原则
![lycz1.png](https://e1sewhere.github.io/images/lycz1.png)
![lypp.png](https://e1sewhere.github.io/images/lypp.png)
172.16.0.0/16开始往里走，下一个我们看到的网络号是172.16.10.0/24，这很明显是应用了VLSM可变长子网掩码之后，得到的一个172.16.0.0/16这个主类网络的一个子网。所以所谓的子网，我们可以理解为是在网络号所属类别的默认掩码长度的基础上，将掩码“拉长”或者向主机位借位从而得到的一个网络号。实际上172.16.0.0/16是将172.16.10.0/24囊括在内的一个区间。那么在这里，如果我们有一个IP：172.16.10.1，实际上这个IP既可以理解为在172.16.0.0/16网络内，也是在172.16.10.0/24网络内，当然，这里我们能看出来，谁更精确呢？很明显是172.16.10.0/24更精确，我们说，它的匹配长度相比172.16.0.0更长

#### 路由迭代查找
![ddcz.png](https://e1sewhere.github.io/images/ddcz.png)
直接寻找目的地址,目的地址不在直连网段,查看下一跳地址,如此迭代,直到下一跳地址在直连网段,从这个接口开始转发.

#### 默认路由转发
![mrlyzf.png](https://e1sewhere.github.io/images/mrlyzf.png)

### 路由表的来源
+ 直连路由:开销小，配置简单，无需人工维护。只能发现本接口所属网段的路由。
+ 手工配置的静态路由:无开销，配置简单，需人工维护，适合简单拓扑结构的网络。
+ 路由协议发现的路由:开销大，配置复杂，无需人工维护，适合复杂拓扑结构的网络。

### 路由度量值(Metric)
>路由度量值表示到达目的地址的代价。
>通常影响路由度量值的因素：
线路延迟、带宽、线路使用率、线路可信度、跳数、最大传输单元
>不同路由协议参考的因素不同

| 路由类型  | 度量值参考因素 |
| :------------- | :--------------------- |
| 静态路由（Static） | 固定值，0 |
| OSPF路由协议 | 带宽 |
| RIP路由协议 | 跳数 |

### 路由优先级
如果到相同目的地址有多个路由来源，则：
> - 以Preference（优先级）确定不同类型优先级；
> - Preference值越小，优先级越高；
> - 优先级最高的路由被添加进路由表;

### 路由优环路
![lyhl.png](https://e1sewhere.github.io/images/lyhl.png)

### 路由原理
1. 当一台主机要发送数据包给同一网络中的另一台主机时，它将直接把数据包送到网络上；
2. 要送给不同IP网络中的主机时，它将选择一个能到达目标网络的路由器或缺省网关（default gateway），由它负责把数据包送到目的地。
3. 路由器转发数据包时，只根据目标IP地址的网络部分，查找路由表，选择合适的接口，将数据包发送出去。
 1. 如果路由器的接口所连接的就是目标网络，将直接通过接口把包送到目标网络；
 2. 否则，将选择其他邻居路由器。路由器也可以有它的缺省网关，用来传送不知道往哪儿送的IP包。
4. 路由器把知道如何传送的IP包转发出去，不知道的IP包送给缺省网关，通过不断的转发，数据包最终将送到目的地，送不到目的地的则被丢弃。


## 静态路由
![jtly.png](https://e1sewhere.github.io/images/jtly.png)

## 缺省路由
特殊的静态路由
![qsly.png](https://e1sewhere.github.io/images/qsly.png)

## 路由协议
### 路由协议与可路由协议
+ 路由协议
 + 路由器用来计算、维护网络路由信息的协议，通常有一定的算法，工  作在网络层或应用层。
 + 常见的路由协议有OSPF、RIP、BGP等。
+ 可路由协议
 + 可被路由器转发的协议，工作在网络层。
 + 常见的可路由协议有IP、IPX等。

### 路由协议基本原理

+ 网络中所有路由器须实现相同的某种路由协议，并已经启动该协议
+ 邻居发现:路由器发送广播、组播、单播报文给指定的路由器邻居，以主动把自己介绍给网段内的其它路由器。
+ 交换路由:每台路由器将自己已知的路由相关信息发给相邻路由器。
+ 计算路由:每台路由器运行某种算法，计算出最终的路由。
+ 维护路由:路由器之间通过周期性地发送协议报文来维护邻居信息。

### 路由协议在协议栈中的位置
![luxy.png](https://e1sewhere.github.io/images/luxy.png)
![lywz.png](https://e1sewhere.github.io/images/lywz.png)

### 路由协议分类
主机A想要通过路由器与主机B进行通信，路由器上必须要有到达主机A和主机B的路由，以此才能完成双方的数据转发。一旦路由器的一个接口与一台网络设备相连，路由器就会学习到该设备所在的网段的路由，这是直连路由。除此之外，还有静态路由和动态路由两种路由协议来获取路由。

1. 静态路由
手动路由
缺省路由
2. 动态路由
距离矢量路由协议：
RIP BGP
链路状态路由协议
OSPF ISIS

#### 内部/外部协议
![lyfl.png](https://e1sewhere.github.io/images/lyfl.png)

#### 距离矢量协议与链路状态协议
+ 距离矢量路由协议
 + RIP
 + BGP
+ 链路状态路由协议
 + OSPF

#### 距离矢量协议路由原理
根据跳数做为度量值来衡量路径的优先，越小优先


### 路由选路原则
当一台路由器使用了多种路由协议时，会通过多种路由协议学习到可以到达同一目的的多条路由，这些路由条目都会存储在路由器数据库中，但在路由表中只显示最优路由。最优路由的选举遵循路由选路原则：

+ 最长匹配原则：当路由器收到一个IP数据包时，会将数据包的目的IP地址与自己本地路由表中的表项进行bit by bit的逐位查找，直到找到匹配度最长的条目，这叫最长匹配原则。
+ 路由协议优先级：数值越小越优先。
![yxj.png](https://e1sewhere.github.io/images/yxj.png)
+ 度量值metric最小优先：路由协议不同则度量值不能做比较，比如RIP度量值为跳数；OSPF度量值为带宽；EIGRP度量值为带宽+延迟等。所以在不同种协议之间先比较管理距离。

### 路由协议的主要指标
+ 协议计算的正确性
协议使用的算法能够计算出最优的路由，且正确无自环。
+ 路由收敛速度
当网络的拓扑结构发生变化之后，能够迅速感知并及时更新相应的路由信息。
+ 协议占用系统开销
路由器在运行路由协议时，需要消耗系统资源（内存、CPU、网络带宽），由于原理的不同，OSPF路由计算所需的资源要大于RIP。
+ 协议自身的安全性
协议自身不易受攻击，有安全机制。OSPF、RIPV2有相应的安全机制，而RIPV1没有。
+ 协议适用网络规模
协议可以应用在何种拓扑结构和规模的网络中。

# RIP路由协议

## 协议概述
+ RIP:Routing Information Protocol（路由信息协议）
+ RIP是一种基于距离矢量（Distance-Vector）算法的路由协议。
+ RIP协议适用于中小型网络，分为RIPV1和RIPv2。>RIP支持水平分割、毒性逆转和触发更新等工作机制防止路由环路。
+ RIP协议基于UDP传输，端口号520。

## RIP工作原理
### RIP路由表的初始化
![ripcs.png](https://e1sewhere.github.io/images/ripcs.png)

### RIP路由表的更新
3条原则：
（1）对本路由表中已有的路由，邻居相同时，新的替换旧的；
（2）对本路由表中已有的路由，邻居不同时，近的替换远的；
（3）对本路由表中没有的路由，且度量值<16时，增加。
路由器会从每个邻居处发现到达目的地的最佳路径
### RIP定时器
（1）Update：发送路由更新的时间间隔，默认30秒；
（2）Timeout：定义老化时间，如果在老化时间内没有收到某条路由的更新报文，则该条路由的度量值被设置为16，并从路由表中撤销，默认值180秒。
（3）Garbage-Collect：定义了一条路由从度量值16开始，直到它从路由表里被删除所经历的时间，默认值120秒。

### RIP路由表维护
+ 周期性发送Response信息
+ 从一台路由器到另一台路由器逐步进行更新

### RIP 特点 (重点)
1. 基于距离矢量算法的协议，距离矢量路由协议是根据距离和方向来衡量路径的优劣
2. 使用跳数来衡量到达目的地的开销（跳数，是指每经过一个三层设备算一跳）
3. 应用在规模较小的网络，现在几乎被淘汰，现网中几乎看不到，主流是OSPF
4. 配置简单，易于维护
5. 周期性的更新，更新周期为30s，每次更新自己所有的路由条目
6. RIP规定，最多支持15跳，16跳代表不可达
7. 直连网络的跳数默认为0
8. RIP有两个版本V1和v2，基本都是用v2版本，默认是v1

## RIP路由协议环路避免机制
### 路由毒化
路由毒化（主动把发生故障的路由项度量值设为16）

### 水平分割
水平分割（从某个接口学到的路由，不会再从该接口发送给这个邻居路由器）

### 毒性逆转
毒性逆转（从某个接口学到路由后，将该路由的度量值设置为无穷大（16），并从原接口发回邻居路由器）

### 定义最大值
定义最大值（16）
>路由项度量值达到16后，路由器将丢弃到达10.4.0.0的数据包而不再转发；
>但在最大值到达之前，环路会存在，最大值只是一种补救措施，只能减少环路存在的时间，并不能避免。

### 抑制时间
环路避免机制五：抑制时间（当一条路由的度量值变为无穷大，该路由进入抑制状态。只有来自同一邻居且度量值小于16的路由更新才会被接收，取代不可达路由。）

### 触发更新
触发更新（不必等到更新周期到来，路由器马上发送路由更新给相邻路由器）

### 总结(记住名字就好)
RIP路由协议环路避免机制
由于RIP是典型的距离矢最路由协议，具有距离矢量路由协议的所有特点。所以，当网络发生故障时，有可能会发生路由环路现象。
RIP设计了一些机制来避免网络中路由环路的产生。这些机制如下：**路由毒化、水平分割、毒性逆转、定义最大值、抑制时间、触发更新**
环路避免机制一：路由毒化
所谓路由毒化(RoutePoisoning)就是路由器主动把路由表中发生故障的路由项以度量值无穷大(16)的形式通告给RIP邻居，以使邻居能够及时得知网络发生故障。
在图所示的网络中，当RTC的直连网络10.4.0.0发生故障时，RTC在路由更新信息里把路由项10.4.0.0的度量值置为无穷大(16)，通告给RTB。RTB接收路由更新信息后，更新自已的路由表，路由项10.4.0.0的度量值也置为无穷大(16)。如此将网络10.4.0.0 不可达的信息向全网扩散。
通过路由毒化机制，RIP协议能够保证与故障网络直连的路由器有正确的路由信息。
环路避免机制二：水平分割
分析距离矢量路由协议中产生路由环路的原因，最重要的一条就是因为路由器将从某个邻居学到的路由信息又告诉了这个邻居。
水平分割是在距离矢量路由协议中最常用的避免环路发生的解决方案之一。水平分割的思想就是RIP路由器从某个接口学到的路由，不会再从该接口发回给邻居路由器。
在图所示的网络中，RTC把它的直连路由10.4.0.0通告给RTB，也就是RTB从RTC那里学习到了路由项10.4.0.0.接口为S1/0。在接口上应用水平分割后，RTB在接口S1/0，上发送路由更新时，就不能包含路由项10.4.0.0。
当网络10.4.0.0发生故障时。假如RTC并没有发送路由更新给RTB，而是RTB发送路由更新给RTC，此时由于启用了水平分割，RTB所发的路由更新中不会包含路由项10.4.0.0。这样，也不会使RTC错误地从RTB学习到关于10. 4.0.0的路由项，从而避免了路由环路的产生。
为了阻止环路，在RIP协议中水平分割默认是被开启的。
环路避免机制三：毒性逆转
毒性逆转是另一种避免环路的方法。毒性逆转是指RIP从某个接口学到路由后，将该路由的度量值设置为无穷大(16)，并从原接口发回邻居路由器。
在图所示的网络中，应用毒性逆转后，RTB在发送路由更新给RTC时，更新中包含了路由10.4.0.0，度量值为16. 相当于明显地告诉RTC，不可能从RTB到达网络10.4.0.0。
毒性逆转与水平分割有相似的应用场合和功能。但与水平分割相比，毒性逆转更加健壮和安全。因为毒性逆转是主动把网络不可达信息通知给其他路由器。毒性逆转的缺点是路由更新中路由项数量增多，浪费网络带宽与系统开销。
环路避免机制四：定义最大值（16）
在多路径网络环境中，如果产生路由环路，则会使路由器中路由项的跳数不断增大，网络无法收敛。通过给每种距离矢量路由协议度量值定义一个最大值，能够解决上述问题。
在RIP路由协议中，规定度量值是跳数，所能达到的最大值为16。其实，在前面的例子中，已经使用跳数16来表示度量值的最大值了。
在图所示的网络中，环路已经产生了。RTA向RTB发送路由项10. 4.0.0的更新信息，RTB再向RTC发送，RTC再向RTA发送，每个路由器中路由项10.4.0.0的跳数不断增大，网络长时间无法收敛，去往网络10.4.0.0的数据报文在网络中被循环发送。
RIP定义了最大度量值后，当路由项的跳数到达最大值16时，图中网络10.4.0.0被认为是不可达的。路由器会在路由表中显示网络不可达信息，并不再更新到达网络10.4.0.0的路由。此时如果路由器收到去往网络10. 4.0.0的数据包，它会将其丢弃而不再转发。
通过定义最大值，距离矢量路由协议可以解决发生环路时路由度量值无限增大的问题，同时也校正了错误的路由信息。但是，在最大度量值到达之前，路由环路还是会存在。也就是说，定义最大值只是一种补救措施，只能减少路由环路存在的时间，并不能避免环路的产生。
环路避免机制五：抑制时间
抑制时间与路由毒化结合使用，能够在一定程度上避免路由环路产生。抑制时间规定，当一条路由的度最值变为无穷大(16)时，该路由将进人抑制状态。在抑制状态下，只有来自同一邻居且度量值小于无穷大(16)的路由更新才会被路由器接收，取代不可达路由。
在图所示网络中，抑制时间机制作用的过程如下:
(1)当网络10.4.0.0发生故障时，RTC毒化自己路由表中的路由项10. 4. 0.0，使其度量值为无穷大(16)，以表明网络10.4.0.0不可达。同时给路由项10. 4.0.0设定抑制时间。在更新周期到来后，发送路由更新给RTB。

(2)RTB收到RTC发出的路由更新信息后，更新自已的路由项10.4.0.0，同时启动抑制时间，在抑制时间结束之前的任何时刻，如果从同一相邻路由器RTC又接收到网络10.4.0.0可达的更新信息，路由器就将路由项10.4.0.0标识为可达，并删除抑制时间。
(3)在抑制时间结束之前的任何时刻，如果接收到其他的相邻路由器如RTA的有关网络10.4.0.0的更新信息，路由器RTB会忽略此更新信息，不更新路由表。
(4)抑制时间结束后，路由器如果收到任何相邻路由器发出的有关网络10.4.0.0的更新信息，路由器都将会更新路由表.
环路避免机制六：触发更新
触发更新机制是指当路由表中路由信息产生改变时，路由器不必等到更新周期到来，而立即发送路由更新给相邻路由器。
在图所示网络中，当网络10.4.0.0 产生故障后，RTC不必等待更新周期到来，而是立即发送路由更新消息以通告网络10.4.0.0不可达信息，RTA、RTB接收到这个信息后，也立即向邻居发送路由更新消息，这样网络10.4. 0.0不可达信息会很快传播到整个网络。
由以上工作机制可以看出，触发更新机制能够使网络不可达信息快速地传播到整个网络，从而极大地加快了网络收敛速度。
使用触发更新方法能够在一定程度上避免路由环路发生。但是，仍然存在如下两个问题。
(1)触发更新信息在传输过程中可能会被丢掉或损坏。
(2)如果触发更新信息还没有来得及发送，路由器就接收到相邻路由器的周期性路由更新信息，则使路由器更新了错误的路由信息。
抑制时间和触发更新相结合，就可以解决上述问题。在抑制时间内，路由器不理会从其他路由器传来的相关路由项可达信息，相当于确保路由项的不可达信息不被错误的可达信息所取代。

在以上机制中，路由毒化、水平分割、毒性逆转能够使RIP协议在单路径网络中避免路由环路，而其余几种主要是针对多路径网络中环路避免而设计的。但在实际网络应用中，以上几种环路避免机制经常被同时应用，以更好地避免环路。
环路避免操作示例
在实际网络中，各种防止环路机制会结合起来共同使用，从而最大可能地避免环路，加快网络收敛。图所示为一个各种机制综合作用的示例。
在图所示网络中，当网络10.4.0.0发生故障时，会有下面的情形发生。
(1)路由毒化。当RTC检测到网络10.4.0.0故障时，RTC毒化路由表中路由项10.4.0.0，使到此网络的跳数为无穷大。
(2)设定抑制时间。RTC给路由项10.4.0.0设定一个抑制时间，其默认值为120秒。
(3)发送触发更新信息。RTC向RTA、RTB发送触发更新信息，指出网络10.4.0.0故障。RTA、RTB接收到触发更新信息以后，使路由项10.4.0.0进人抑制状态，在抑制状态下不接收来自其他路由器的相关更新。然后，RTA和RTB也向其他接口发送网络10.4.0.0故障的触发更新信息。
至此，全网所有路由器的路由表中表项10.4.0.0的度量值均为无穷大，并且进人抑制状态，路由器会丢弃目的地为网络10. 4，0.0的数据包。
网络10.4.0.0恢复正常后，RTC解除抑制时间。同时用触发更新向RTA、RTB传播。RTA、RTB也解除抑制时间，路由表恢复正常。

## RIPv1缺点
>RIPv1发送协议报文时不携带掩码，路由交换过程中有时会造成错误。
>不支持认证
>只能以广播方式发布协议报文

## RIPv2改进
>RIPv2是一种无类别路由协议（Classless Routing Protocol）。
>RIPv2协议报文中携带掩码信息，支持VLSM（可变长子网掩码）和CIDR。
>RIPV2支持以组播方式发送路由更新报文，组播地址为224.0.0.9，减少网络与系统资源消耗。
>RIPV2支持对协议报文进行验证，并提供明文验证和MD5验证两种方式，增强安全性。


## v1v2对比

| 项目 | RIPv1 | RIPv2 |
| :---------------------------------- | -----------: | ---------------------: |
| 路由协议 | 有类无类 |
| 是否支持可变长子网掩码？ | 否 | 是 | 
| 子网掩码是否随路由更新一起发送？ | 否 | 是 | 
| 地址类型 | 广播 | 组播 |
| 定义于 | RFC 1058 | RFC 1721、1722和2453 |
| 是否支持手动路由总结？ | 否 | 是 |
| 是否支持身份验证？ | 否 | 是 |


# OSPF路由协议
## RIP的缺陷
+ 以跳数评估的路由并非最优路径
![ripqx1.png](https://e1sewhere.github.io/images/ripqx1.png)
+ 最大跳数16导致网络尺度小
+ 收敛速度慢
![qx2.png](https://e1sewhere.github.io/images/qx2.png)
+ 更新发送全部路由表,浪费网络资源

## OSPF基本原理
### 链路状态路由协议
将开销值作为度量值，每台路由器都会收到自己区域内的所有路由信息，自己进行SPF算法（最短路径优先算法），选出最优路径。
![ospf1.png](https://e1sewhere.github.io/images/ospf1.png)

### 什么是OSPF
>OSPF（Open Shortest Path First，开放最短路径优先）是基于链路状态的自治系统内部的路由协议；
>链路或接口的状态：UP/Down、IP地址、掩码、带宽、利用率、时延等；
>OSPF仅传播对端设备不具备的路由信息，网络收敛迅速，并有效避免了网络资源浪费；
>OSPF直接工作于IP层之上，IP协议号为89,且自己定义了一些安全机制;
>OSPF以组播地址发送协议包。


### SPF算法
将每台路由器放置在树的根节点，并根据累计开销计算到达每个目的地的最短路径，开销越低，路径越好
开销=参考带宽/接口带宽（b/s）


### 工作过程
![gzgc.png](https://e1sewhere.github.io/images/gzgc.png)
OSPF协议工作过程主要有四个阶段：
寻找邻居、建立邻接关系、链路状态信息传递、计算路由

#### 寻找邻居
![xzlj.png](https://e1sewhere.github.io/images/xzlj.png)

#### 建立邻接关系
采用DR/BDR方式建立邻接关系

#### DR和BDR选举
> 路由器优先级取值：0~255，优先级最高（Pri最大）的将被宣告为DR，优先级为0的路由器不具备选举资格。
>邻接关系数R=2（n-2）+1
>优先级相同，Router ID大的优先。
>DR和BDR一旦选定，即使新增优先级更高的路由器，DR和BDR也不重新选举，只有当DR和BDR都失效后，才参与选举。
>一台路由器多个接口启用OSPF，这些接口分别属于不同的网络，这台路由器可能是其中一个网络的DR，而不是其他网络的DR。
>DR是路由器接口的特性，不是整台路由器的特性。DR是某个网络的DR，而不是全网的DR。
>邻居关系与邻接关系不同。OSPF区域内的路由器可以互为邻居，但只与DR、BDR建立邻接关系。

#### 链路状态信息传递
![llztcd.png](https://e1sewhere.github.io/images/llztcd.png)
为了避免网络资源浪费，路由器采用路由增量更新机制：
>只发布邻居缺少的链路状态给邻居；
>四次握手，避免了RIP发送全部路由浪费网络资源的问题，还可保证路由器之间信息传递的可靠性。
>当网络变化时，路由器立即向已经建立邻接关系的邻居发送LSA摘要信息；
>如果网络未发生变化，路由器每隔30分钟向已经建立邻接关系的邻居发送一次LSA摘要信息。

#### 计算路由
![jsly.png](https://e1sewhere.github.io/images/jsly.png)

### 等价路由
目的地相同且cost相同,的不同路由

作用
>路由备份
>>到相同目的地址的下一跳和优先级都不同
>>优先级高的为主，低的为备

>负载分担
>>到相同目的地址的下一跳不同，但优先级相同
>>到目的地的流量将均匀分布

### OSPF协议分区域管理
![区域管理.png](https://e1sewhere.github.io/images/区域管理.png)
OSPF自治系统内的通信将划分为3种类型区域内通信：

+ 在同一个区域内的路由器之间的通信。
+ 区域间通信：不同区域的路由器之间的通信。
+ 区域外部通信：OSPF域内路由器与另一个自治系统内的路由器之间的通信。

>骨干区域
区域ID号：区域0所有的区域间通信都必须通过该区域
>非骨干区域
所有非骨干区域都必须与骨干区域相连，非骨干区域之间不能直接交换数据包


>骨干路由器（Bachbone Router，BR）：至少有一个接口与骨干区域相连的路由器
>区域边界路由器（Area Border Routers，ABR）：连接一个或多个区域到骨干区域的路由器
>内部路由器（Internal Router）：所有接口都属于同一个区域的路由器
>自治系统边界路由器（Autonomous System Boundary Router，ASBR）：OSPF区域内的路由器与其他自治系统相连的路由器

#### OSPF协议区域LSA发布
![lsafab.png](https://e1sewhere.github.io/images/lsafab.png)
### OSPF优势

>所有路由器对整个网络的拓扑有相同的认识，在此基础上计算的路由不可能产生环路。
>网络结构变化，收敛速度快。
>每台路由器都有自己的RouterID号，能够很好地被跟踪。
>使用SPF算法计算路由，路由选择与网络能力直接联系，更合理。
>采用多种手段保证信息传递的可靠性，同时避免了不必要的网络资源浪费（缺失的LSA、30分钟）。

## OSPF实施
### 配置单区域
### 配置环回接口(了解不考)
### OSPF身份验证
OSPF 支持以下几种类型的身份验证：
>空（无身份验证）(type0)
>明文（或简单）口令身份验证(type1)
>MD5身份验证(type2)
路由器生成并检查每个OSPF 数据包路由器验证接收到的每个路由更新数据包的来源配置“密钥”（口令）；每个参与的邻居都必须配置相同的密钥


# 交换网络
## VLAN间路由

## 交换式以太网
交换机比网桥端口多,转发能力强.

### 一些场景下的命令

### VLAN作用
1. 限制广播域：广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。
2. 增强局域网的安全性：不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。
3. 提高了网络的健壮性：故障被限制在一个VLAN内，本VLA N内的故障不会影响其他VLAN的正常工作。
4. 灵活构52






#
# Cisco实验

## 基本配置命令
从用户模式切换到特权模式:`enable`
从特权模式到全局配置模式:`configure terminal`或者`conf t`
从全局配置模式到接口模式`interface 接口类型 接口号`
推回到之前的模式:`exit`
强制回到特权模式:`end`  或者`ctrl+z`
关闭命令查找:`no ip domain-lookup`
修改路由器名称:`hostname [name]`
撤回命令:`no [需要撤回的命令]`
### 特权模式下的命令
1. 显示所有配置:`show running`
1. 显示版本号和寄存器值:`show version`
1. 查看vlan所有的信息:` show vlan`
1. 查看端口状态:` show interfaces`
1. 查看所有配置信息:`show run`
1. 查看接口摘要信息: `showip interface brief`
1. 查看主机表: `show hosts`
1. 查看历史记录: `show history`
1. 将配置文件保存: `write`

### 全局配置模式下的命令
1. 创建vlan10:`vlan 10 `
2. 在vlan模式下给vlan10命名:`name xxx`
3. 删除vlan10:`no vlan 10`
4. 检查静态路由配置:`show ip route`

### 接口模式下的命令
1. 关闭接口:`shutdown`
2. 打开接口:`no shutdown`
3. 配置ip地址:`ip add ip地址 子网掩码`
4. 交换机端口转换为access模式:`switchport mode access`
5. 将这个端口划分给vlan 10: `switchport access vlan 10`
6. 将这个端口从vlan10中删除: `no switchport access vlan 10`




#### TELNET远程登录
# 遇到的问题

+ ~~首部 协议的作用?~~
+ ~~流量控制,拥塞控制的作用,区别~~
+ ~~UDP的错误检查~~
+ ~~私有ip为什么不从0开始~~
+ ~~网络层独立处理数据包~~
+ ~~网络层 流量控制~~
+ ~~TCP固定窗口 标签查看~~
+ ~~固定窗口和滑动窗口区分使用~~

# 需要重看的内容

+ TCP头,TCP握手过程计算
+ OSI模型作用,单位等
+ 子网划分合并练习题
+ Cioc命令
+ 二层主机通信,三层通信
+ telnet 远程登录